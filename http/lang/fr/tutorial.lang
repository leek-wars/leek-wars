advanced			Avancé
advanced_include			Les inclusions
advanced_include_1			La fonction <b>include</b> permet d'inclure une IA dans une autre. Concrètement, si dans une IA "IA Principale", vous écrivez :
advanced_include_10			// ne fonctionne pas
							var ias = ['IA_1', 'IA_2', 'IA_3'];
							for (var ia in ias) {
								include(ia);
							}
advanced_include_11			Pourquoi ?
advanced_include_12			La raison est que le compilateur du LeekScript réalise les inclusions à la compilation uniquement. L'inclusion d'une IA à l'éxécution (exemple : si l'ennemi est proche de moi, inclure "IA_Fuite") n'est pas supporté. Les IA incluses dans les autres doivent être déterminées à la compilation, c'est pourquoi la seule façon d'include une ia est :
advanced_include_13			// Fonctionne
							include("chaine_de_caractères");
advanced_include_2			include("Fonctions");
advanced_include_3			Le contenu de l'IA se nommant "Fonctions" est recopié dans l'IA "IA Principale", ce qui vous permet de séparer différentes parties de votre code dans différentes IA.
	Un exemple : avoir une IA principale, appelée "IA Principale", une IA "Déplacement" contenant plusieurs fonctions complexes pour se déplacer, une IA "attaque" contenant des fonctions utiles pour attaquer, une IA "Paroles", avec des fonctions permettant de parler etc.
advanced_include_4			Séparer son code par thème dans différentes IAs, des modules, permet de les réutiliser plus facilement ensuite. Si vous avez deux poireaux, il vous suffit de faire deux IA incluant toutes les deux les
							différents modules, sans devoir recopier le code dans les deux IA.
advanced_include_5			Limites de la fonctions include
advanced_include_6			L'utilisation de la fonction include est limitée en LeekScript, en effet il est impossible d'inclure dynamiquement une autre IA. Les codes ci-dessous ne fonctionnent pas :
advanced_include_7			// ne fonctionne pas
							include("IA_" + 5);
advanced_include_8			// ne fonctionne pas
							var ia = 'IA_1';
							include('IA_1');
advanced_include_9			// ne fonctionne pas
							if (foo > 12) {
								include('IA_1');
							} else {
								include('IA_2');
							}
advanced_intro			Dans cette section nous présenterons des fonctions et techniques plus complexes mais néanmoins utiles pour gagner un combat
	dans <b>Leek Wars</b>.
advanced_order			Ordre de jeu
advanced_order_1			Les fonctions <a href='documentation/getNextPlayer'><b>getNextPlayer</b></a> et
	<a href='documentation/getPreviousPlayer'><b>getPreviousPlayer</b></a> permettent de récupérer les ids des poireaux qui, respectivement,
	va jouer après vous et qui a joué avant vous.
	Une application possible : regarder si le joueur qui joue après vous (un ennemi) est proche de vous.
advanced_order_2			var next = getNextPlayer();
							if (isEnemy(next) and getLife() < 100
								and getCellDistance(getCell(), getCell(next)) < 10) {
								// On est en danger, le prochain joueur est un ennemi, proche
							}
advanced_order_3			Cibles d'une arme ou d'une puce
advanced_order_4			Les fonctions <a href='documentation/getWeaponTargets'><b>getWeaponTargets</b></a> et
	<a href='documentation/getChipTargets'><b>getChipTargets</b></a> permettent de récupérer un tableau d'id des poireaux touchés
	si vous utiliser une arme ou une puce sur une certaine cellule. Particulèrement utiles pour les armes ou puces de zone (aussi bien
	un lance-grenades qu'un sort de soin en zone) :
advanced_order_5			var cell = ...; // une cellule
							var targets = getChipTargets(CHIP_ICEBERG, cell);
							if (count(targets) > 1) { // on touche plus d'un joueur en lançant ici
								for (var target in targets) {
									if (isAlly(target)) {
										// On touche un allié, pas bon :/
									}
								}
							}
advanced_ref			Le passage par référence
advanced_ref_1			Quand vous écrivez une fonction en LeekScript, vous pouvez lui préciser des arguments, par exemple :
advanced_ref_2			function somme(a, b, resultat) {
							resultat = a + b;
						}
advanced_ref_3			Quand vous allez appeler cette fonction, les variables que vous lui passez seront <b>copiées</b>, c'est à dire que si vous faites :
advanced_ref_4			function somme(a, b, resultat) {
							resultat = a + b;
						}

						var a = 2;
						var b = 10;
						var resultat = 0;

						somme(a, b, resultat);
						debug(resultat);
advanced_ref_5			Ici, le programme affichera 0, car la variable resultat vaudra 0. Quand vous passez ces 3 variables (a, b et resultat) dans la fonction "somme",
		leurs valeurs sont recopiées pour être utilisées à l'intérieur. Ainsi, les valeurs 2, 10 et 0 sont envoyées. L'opération "resultat = a + b" travaille donc avec des copies des valeurs, et ne va pas affecter votre variable "resultat".
advanced_ref_6			Il est possible de résoudre le problème en passant "resultat" par référence. Pour ce faire, il suffit de rajouter un "@" devant son nom dans la liste des arguments de la fonction :
advanced_ref_7			function somme(a, b, @resultat) {
							resultat = a + b;
						}

						var a = 2;
						var b = 10;
						var resultat = 0;

						somme(a, b, resultat);
						debug(resultat); // "resultat" vaut bien 12.
advanced_tern			Les ternaires
advanced_tern_1			Les ternaires sont un moyen plus rapide d'écrire une condition. La structure d'une condition ternaire est :
advanced_tern_2			condition ? valeur_si_vrai : valeur_si_faux
advanced_tern_3			Ainsi, on peut remplacer :
advanced_tern_4			if (getCell() == 42) {
							useWeapon(getNearestEnemy());
						} else {
							moveTowardCell(42);
						}
advanced_tern_5			par le code suivant :
advanced_tern_6			(getCell() == 42) ? useWeapon(getNearestEnemy()) : moveTowardCell(42);
advanced_tern_7			Les deux codes si-dessus sont équivalents. Les ternaires permettent de condenser son code pour des conditions simples,
	mais attention néanmoins à ne pas en abuser, cela pourrait rendre votre code difficilement lisible.
advanced_triple_equal			L'opérateur ===
advanced_triple_equal_1			L'opérateur <b>===</b> permet de comparer deux valeurs, ainsi que leur type. Il est plus restrictif que l'opérateur <b>==</b>.
advanced_triple_equal_2			<tr><th>Opérateur</th><th>Description</th></tr>
								<tr><td>===</td><td>Vérifie si les deux opérandes sont de même valeur et de même type</td></tr>
								<tr><td>!==</td><td>Vérifie si les deux opérandes ne sont pas de même valeur ou ne sont pas de même type</td></tr>
advanced_triple_equal_3			Le fonctionnement de l'opérateur <b>===</b> est très simple :
advanced_triple_equal_4			Celui de <b>==</b>, en revanche, est plus complexe, car il tente d'effectuer certaines conversions :
advanced_triple_equal_5			Le fonctionnement global du <b>==</b> est de convertir les valeurs quand ces deux dernières ne sont pas de même type, par exemple, "true" == 1,
		"lama" == true, 12 == true, mais, 1 != 12 et "true" != "lama". Quand les deux valeurs sont de même type, le <b>==</b> a le même comportement que <b>===</b>.
advanced_triple_equal_6			Quand le <b>==</b> compare un tableau a un seul élément, ce tableau est assimilé à cet élément. Par exemple, 1 == [1], "1" == ["1"], et par conséquent "1" == [1] et 1 == ["1"]. Par récusivité, on a également 1 == [[1]], 1 == [[[1]]] etc.
advanced_triple_equal_7			L'opérateur <b>==</b> est donc à utiliser avec précaution, si vous souhaitez être sûr du test d'égalité entre les deux valeurs, utilisez <b>===</b>.
arr_1			Il y a un autre type de variable que nous avons rapidement évoqué tout à l’heure : les tableaux.
	Jusqu’à présent, les variables que nous avons vues ont toutes un nom et une valeur, les tableaux ont
	également un nom, mais il est possible de leur associer plusieurs valeurs, elles sont alors rangées dans des “cases”.
arr_10			Dans les deux cas le tableau obtenu peut être représenté ainsi :
arr_11			<tr><th>Indice</th><th>Valeur</th></tr>
				<tr><td>0</td><td>Poireau</td></tr>
				<tr><td>1</td><td>Lama</td></tr>
				<tr><td>2</td><td>Autruche</td></tr>
				<tr><td>3</td><td>Artichaut</td></tr>
arr_12			On peut accéder à une case d’un tableau en indiquant l’indice de la case à laquelle
				on souhaite accéder entre crochets :
arr_13			// Déclaration du tableau
				var monTableau = ["Poireau", "Lama", "Autruche", "Artichaut"];
				debug(monTableau[1]); // Affichera Lama
arr_14			On peut utiliser une case d’un tableau exactement comme une variable normale :
arr_15			var monTableau = [2, 4, 6, 8];
				debug(monTableau[0]); // Affiche 2
				monTableau[0] = monTableau[1] + 5; // Assigne la valeur 9 à la case 0
				debug(monTableau[0]); // Affiche 9
arr_16			Lorsqu’on concatène un tableau avec une chaîne de caractères ou qu’on tente de l’afficher avec la fonction debug,
	on voit apparaître la liste de tous ses éléments, c’est très pratique pour le débugage.
arr_2			Les tableaux proposés pas le LeekScript sont des tableaux à indice (ou clé) numériques, vous pouvez y
	stocker n’importe quel type de valeur (y compris un autre tableau) ou encore y mettre un type différent
	d’une case à l’autre.
arr_3			Le premier indice d’un tableau sera toujours 0 et il est impossible d’utiliser des indices négatifs
arr_4			Pour créer un tableau, il faut utiliser la syntaxe suivante :
arr_5			// Déclaration d’un tableau
				var monTableau = [];
arr_6			On peut remplir notre tableau de deux manières :<br />
	A l’initialisation :
arr_7			// Déclaration du tableau
				var monTableau = ["Poireau", "Lama", "Autruche", "Artichaut"];
arr_8			Ou après l’initialisation, en utilisant des assignations :
arr_9			// Déclaration du tableau
				var monTableau = [];
				monTableau[0] = "Poireau";
				monTableau[1] = "Lama";
				monTableau[2] = "Autruche";
				monTableau[3] = "Artichaut";
arrays			Les tableaux
automatic_completion			La complétion automatique
buy_a_weapon			Avant de faire combattre votre poireau, il est impératif de lui donner de quoi attaquer. Rendez vous dans
	l’onglet “Marché” afin d’acheter une arme. La page “Marché” se compose de deux sous-onglets : “Armes” et “Puces”.
	Pour ce tutoriel nous allons acheter une arme mais le mécanisme est similaire pour une puce.
buy_a_weapon_2			Choisissez dans la liste l’arme qui vous plaît (et dont le niveau minimal est inférieur à celui de votre poireau),
	cliquez sur le bouton “Acheter”.
buy_a_weapon_3			Rendez vous ensuite dans l’onglet “Poireau”, en bas de cette page vous pouvez voir trois colonnes : Armes, Puces et IA.
	Cliquez sur le lien “Modifier” de la colonne Armes, une petite fenêtre apparaît. Faites glisser votre arme de la
	catégorie “Toutes les Armes” vers “Armes de [nom de votre poireau]”. Et voilà votre arme est équipée.
cond_1			Nous allons aborder un point important du LeekScript (et plus généralement de tout langage) : les conditions !<br />
	Elles vous permettrons de faire exécuter des actions différentes à votre poireau selon les cas.
cond_10			Il est également possible de déterminer plusieurs cas, imaginons qu’on ait une valeur entre 0 et 10
	et que l’on souhaite exécuter une action différente si cette valeur est entre 0 et 4, entre 5 et 7 ou entre 8 et 10.
	On peut alors utiliser la structure else if (sinon si). Elle permet de définir une nouvelle condition et un nouveau groupe
	d’instructions.
cond_11			Exemple :
cond_12			var valeur = 5;
				if (valeur < 5) { // Si valeur est inférieur à 5 (entre 0 et 4 donc)
					debug("Valeur est entre 0 et 4");
				} else if (valeur < 8) { // Sinon si valeur est inférieur à 8 (entre 5 et 7)
					debug("Valeur est entre 5 et 7");
				} else { // Sinon (entre 8 et 10 donc)
					debug("Valeur est entre 8 et 10");
				}
cond_13			Nous allons maintenant voir quels sont les différents opérateurs de condition disponibles :
cond_14			<tr><th>Opérateur</th><th>Description</th></tr>
				<tr><td>==</td><td>Est égal à</td></tr>
				<tr><td>!=</td><td>Est différent de</td></tr>
				<tr><td>&lt;</td><td>Est inférieur à</td></tr>
				<tr><td>&lt;=</td><td>Est inférieur ou égal à</td></tr>
				<tr><td>&gt;</td><td>Est supérieur à</td></tr>
				<tr><td>&gt;=</td><td>Est supérieur ou égal à</td></tr>
cond_15			Il est également possible de combiner plusieurs conditions ensemble grâce aux opérateurs logiques :
cond_16			<tr><th>Opérateur</th><th>Description</th></tr>
				<tr><td>and</td><td>et</td></tr>
				<tr><td>or</td><td>ou</td></tr>
cond_17			Ce qui donne :
cond_18			var a = 1;
				var b = 5;
				if (a < 5 and b > 6) { // Si a est inférieur à 5 et b est supérieur à 6
					// ...
				}
				if (a == 1 or a == 3) { // Si a est égal à 1 ou si a est égal à 3
					// ...
				}
cond_19			Il existe aussi l'opérateur <b>===</b>, qui permet de comparer la valeur et le type de deux valeurs, voir dans <a href='#triple_equals'>la section avancée</a>.
cond_2			Structure if… else…
cond_20			Quelques simplifications utiles
cond_21			Nous allons maintenant voir quelques simplifications au niveau des conditions qui vous permettront
	d’alléger votre code.
cond_22			Si vous ne voulez exécuter qu’une seule instruction dans votre bloc vous pouvez écrire directement
	cette instruction sans accolade :
cond_23			Pour un if par exemple :
cond_24			var a = 1;
				if (a == 1) debug("A est égal à 1");
cond_25			Ou bien pour un if else :
cond_26			if (valeur > 5) debug("valeur supérieur à 5")
				else debug("valeur inférieure ou égale à 5");
cond_27			Cette écriture permet de gagner un peu en lisibilité.
cond_28			Il est également possible d’écrire :
cond_29			var a = 1;
				if (a) debug("A est vrai");
cond_3			Pour utiliser une condition, il faut écrire le mot clé if (si), une condition entre parenthèses,
				puis ouvrir une accolade, écrire les instructions à exécuter lorsque la condition est vérifiée, puis refermer l’accolade.
cond_30			Cette opération va vérifier si la valeur de a est vraie.
cond_31			Si a n'est pas un <b>booléen</b> :
cond_32			Si a est un <b>nombre</b>, toute valeur différente de 0 sera considérée comme vraie.
cond_33			Si a est une <b>chaîne de caractères</b>, a est vraie si elle est non vide.
cond_34			Si a est un <b>tableau</b>, a est vrai si il est non vide.
cond_35			Si a est <b>null</b>, a est faux.
cond_4			Voici un exemple :
cond_5			var a = 1;
				if (a < 10) { // On regarde si a est inférieur à 10
					// Si oui les instructions placées dans les accolades seront exécutées
					debug("a est inférieur à 10");
				}
cond_6			Dans cet exemple, a vaut 1 donc la condition est remplie, donc le debug sera executé et on aura
	"a est inférieur à 10" d’écrit dans les logs.
cond_7			Si on veut exécuter des instructions dans le cas où la condition est vérifiée et d’autres instructions
	quand elle ne l’est pas, il est possible d’utiliser le mot clé <b>else</b> (sinon) pour délimiter un second bloc.
cond_8			Exemple :
cond_9			var a = 1;
				if (a < 10) { // On regarde si a est inférieur à 10
					// Si oui les instructions placées dans les accolades seront exécutées
					debug("a est inférieur à 10");
				} else { // Sinon
					// Instructions à exécuter si a n’est pas inférieur à 10
					debug("a n’est pas inférieur à 10");
				}
conditions			Les conditions
difficulty_child		Enfant : 30 à 40% de vos caractéristiques (force, agilité, vie..) et 50% de vos PT et PM
difficulty_easy			Facile : 50 à 75% de vos caractéristiques et 80% de vos PT, PM
difficulty_evil			Diabolique : 200 à 250% de vos caractéristiques et 160% de vos PT, PM
difficulty_hard			Difficile : 130 à 160% de vos caractéristiques et 130% de vos PT, PM
difficulty_medium		Moyen : 95 à 110% de vos caractéristiques et 100% de vos PT, PM
do_a_test_fight			Faire un combat de test
doc_1			Un dernier point important à aborder avant de commencer ce cours est la documentation. Toutes les fonctions
    et constantes disponibles dans le leekScript sont regroupées sur une page : la documentation.
	Pour accéder à la documentation de <b>Leek Wars</b>, rendez vous dans l’onglet Aide, puis cliquez sur Documentation.
doc_10			Le type de retour de la fonction et une description de ce retour
doc_11			Le niveau minimal pour utiliser cette fonction
doc_12			Si vous avez des doutes sur l’utilisation d’une fonction ou si vous rencontrez une nouvelle fonction dans ce tutoriel
	ou ailleurs, je vous invite à lire sa description dans la documentation afin de bien comprendre son fonctionnement.
doc_13			Maintenant que nous avons fait le tour de l’environnement de programmation, nous allons commencer à voir le LeekScript !
doc_2			La page se compose de trois parties :
doc_3			En haut : un champ de recherche pour trouver plus rapidement une constante ou une fonction
doc_4			À gauche : Une liste de toutes les fonctions et constantes triées par catégorie
doc_5			À droite : Toutes les fonctions dans l’ordre alphabétique ainsi que leur description
doc_6			Les catégories sont les suivantes :
doc_7			La description d’une fonction vous fournis les informations suivantes :
doc_8			Une description sur le rôle de la fonction
doc_9			La liste de ses paramètres, leur type ainsi que leur description
doc_arrays			<b>Tableaux</b> : fonctions classiques de manipulation de tableaux
doc_chips			<b>Puces</b> : fonctions relatives aux puces (récupération d’informations sur une/des puces)
doc_fight			<b>Combat</b> : fonctions relatives au combat en cours (récupération d’informations générales sur l’équipe adverse,
		sur votre équipe, placement par rapport aux positions adverses…)
doc_leeks			<b>Poireaux</b> : fonctions relatives aux poireaux (récupération de statistiques, de position, équipement d’arme…)
doc_map			<b>Terrain</b> :  fonctions relatives au terrain (informations de distance entre cellules, position de cellules…)
doc_math			<b>Math</b> : toutes les fonctions mathématiques qu’on peut trouver dans la plupart des langages
doc_strings			<b>Chaîne</b> : fonctions classiques de manipulation de chaînes de caractères
documentation			La Documentation
doc_util			<b>Utilitaires</b> : fonctions utiles pour vous aider lors du développement de votre IA
doc_weapons			<b>Armes</b> : fonctions relatives aux armes (récupération d’informations sur une/des armes)
editor			Découverte de l’éditeur
editor_1			Pour accéder à l’environnement de programmation, rendez vous sur l’onglet <b>Editeur</b>. <br />
	Voici la page que vous allez trouver :
editor_10			Voici à quoi ressemble le dialogue d’autocomplétion :
editor_11			Une fois que vous avez développé votre IA, vous avez la possibilité de la tester en cours d’édition
    en situation de combat grâce à l’arène de test.
editor_12			En cliquant sur le bouton “Tester”, le dialogue suivant s’ouvre :
editor_13			Vous pouvez alors sélectionner les adversaires que vous souhaitez affronter ainsi que leur niveau de difficulté,
	les statistiques de l’adversaire sont calculées en fonction de celle de votre poireau :
editor_14			Les 6 poireaux proposés ont chacun un comportement propre :
editor_15			Vous pouvez cocher un poireau au minimum et aller jusqu’à 6, vous pouvez ainsi affiner votre test.
editor_2			On trouve un bouton “Nouvelle IA”, il permet de créer une nouvelle IA, et au dessous de ce bouton se trouve la
	liste de vos IA.
editor_3			Lors de la création de votre compte, une IA appelée “IA_Exemple” a été créée et équipée automatiquement afin que vous
	disposiez d’un exemple de code.
editor_4			Cliquez sur cette IA. Un éditeur de texte s’ouvre avec le code :
editor_5			En cliquant sur le nom de l’IA, le champ devient éditable et vous pouvez ainsi la renommer. <br />
	Le bouton “Supprimer” supprime l’IA actuelle. <br />
	Le bouton “Sauvegarder” enregistre le code de votre IA, le compile et vous indique s’il est valide ou s’il
	contient des erreurs. <br />
	Le bouton “Tester” permet de lancer un combat dans une arène de test pour vérifier que votre code s’exécute
	correctement (nous reviendrons sur cette fonctionnalité un peu plus loin).
editor_6			En dessous de ces boutons se trouve un éditeur de texte, c’est ici que vous pouvez taper votre code,
	une coloration syntaxique est appliquée suivant le code couleur suivant :
editor_7			Il est intéressant de noter aussi qu’en plaçant son curseur près d’une parenthèse, accolade ou crochet ouvrant,
	son équivalent fermant est mis en évidence, (inversement quand on place le curseur près d’un fermant).
editor_8			L’éditeur dispose également de raccourcis claviers qui pourront vous faire gagner du temps lors du développement de vos IA :
editor_9			La complétion automatique ouvre un dialogue pour compléter la fonction, variable ou constante que vous
	étiez en train d’écrire avec une déjà connue par l’éditeur. <br>
	L’éditeur connaît toutes les fonctions du LeekScript ainsi que leurs paramètres, les constantes de jeu ainsi
	que les fonctions et variables que vous aurez définies.
editor_domingo			Domingo : IA agressive, uniquement en attaque
editor_guj			Guj : IA incompréhensible, attaque, se soigne, fuit, vient vers vous… personne ne sait</li>
		vraiment ce que ce poireau veut.
editor_image_1			L'Éditeur de code de <b>Leek Wars</b>
editor_image_2			Une IA dans L'éditeur
editor_rioupi			Rioupi : IA lache, fuis principalement
editor_shortcut_1			<b>Ctrl + S</b> : Enregistrer/Compiler
editor_shortcut_2			<b>Ctrl + Q</b> : Lancer un test
editor_shortcut_3			<b>Ctrl + D</b> : Dupliquer la ligne actuelle ou la sélection
editor_tisma			Tisma : IA défensive, attaque fuis et se soigne
editor_token_bool			En turquoise : les booléens
editor_token_comments			En rouge : les commentaires
editor_token_keywords			En bleu : les mots clés du langage (if, else, for, var, while…)
editor_token_numbers			En vert : les valeurs numériques
editor_token_strings			En orange : les chaînes de caractère
equip_a_weapon			Équiper une arme
fight			Combat
fight_chips			Les puces
fight_chips_1			Avant d'utiliser une puce, il faut veiller à l'équiper sur notre poireau. Pour l'utiliser, il suffit d'utiliser la fonction
	<a href='documentation/useChip'><b>useChip</b></a>. Le premier paramètre est le code de la puce, par exemple "<b>CHIP_SHOCK</b>"
	pour la puce "<b>Décharge</b>". Le second paramètre est le poireau ciblé :
fight_chips_10			var enemy = getNearestEnemy();
						while (getTP() >= 2) {
							useChip(CHIP_SHOCK, enemy);
						}
fight_chips_2			var enemy = getNearestEnemy();
						useChip(CHIP_SHOCK, enemy); // On lance la puce Décharge sur l'ennemi

						var ally = getNearestAlly();
						useChip(CHIP_CURE, ally); // On lance la puce Guérison sur un allié
fight_chips_3			La gestion des Points de Tour (PT)
fight_chips_4			Votre poireau possède un nombre limité de points de tour, utilisés pour effectuer des
	actions comme prendre une arme, tirer, utiliser une puce, parler...
fight_chips_5			Par défaut, le nombre de PT est fixé à 10. Vous pouvez en obtenir davantage avec les points de capital.
	Le nombre de PT est réinitialisé à la fin de votre tour.
fight_chips_6			Vous devez donc réfléchir à quelles actions effectuer durant votre tour, et organiser votre code en conséquence.
	La fonction <b>getTP()</b> (get Turn Points) vous donne le nombre de PT restants.
fight_chips_7			Un exemple : on veut lancer le sort "Stalactite" si il nous reste 6 PT ou plus, sinon on lance le sort "Décharge" :
fight_chips_8			var enemy = getNearestEnemy();
						if (getTP() >= 6) {
							useChip(CHIP_STALACTITE, enemy);
						} else {
							useChip(CHIP_SHOCK, enemy);
						}
fight_chips_9			Un autre exemple : on veut lancer le sort "Décharge" (qui coûte 2 PT) jusqu'a épuisement de nos PT :
fight_ground			Le terrain
fight_ground_1			Le terrain sur lequel évoluent les joueurs est une grille
	de <b>613</b> cellules, numérotées dans l'ordre comme le montre la capture ci-dessous :
fight_ground_10			Note : on peut directement utiliser <a href='documentation/isLeek'><b>isLeek()</b></a> pour savoir si une case contient un poireau
fight_ground_11			Coordonnées (x, y)
fight_ground_12			On peut également récupérer les coordonnées
	<b>x</b> et <b>y</b> d'une cellule à l'aide de la fonction <a href='documentation/getCellX'><b>getCellX</b></a> et
	<a href='documentation/getCellY'><b>getCellY</b></a> :
fight_ground_13			var cell = getCell(); // On récupère notre cellule
						var x = getCellX(cell); // Position en x de la cellule
						var y = getCellY(cell); // Position en y de la cellule
fight_ground_14			La cellule centrale du terrain (numéro <b>306</b>) a les coordonnées <b>(0, 0)</b>;
fight_ground_15			La cellule en haut à gauche (numéro <b>0</b>) a les coordonnées <b>(-17, 0)</b>;
fight_ground_16			La cellule en haut à droite (numéro <b>17</b>) a les coordonnées <b>(0, -17)</b>;
fight_ground_17			La cellule en bas à gauche (numéro <b>595</b>) a les coordonnées <b>(0, 17)</b>;
fight_ground_18			La cellule en bas à droite (numéro <b>612</b>) a les coordonnées <b>(17, 0)</b>.
fight_ground_19			Enfin, pour finir avec la gestion des cellules, on peut aussi calculer la distance entre deux cellules (et donc aussi
	entre deux poireaux) à l'aide des fonctions <a href='documentation/getDistance'><b>getDistance</b></a> (distance à vol d'oiseau),
	<a href='documentation/getCellDistance'><b>getCellDistance</b></a> (distance en nombre de cellules) et
	<a href='documentation/getPathLength'><b>getPathLength</b></a> (distance en évitant les obstacles).
	Un exemple, on va calculer la distance entre notre poireau et son ennemi le plus proche :
fight_ground_2			La numérotation des cellules
fight_ground_20			var maCellule = getCell();
						var saCellule = getCell(getNearestEnemy());
						var distance = getCellDistance(maCellule, saCellule);
						if (distance > 10) {
							// l'ennemi le plus proche est à plus de 10 cellules
						}
fight_ground_3			Grâce à cette numérotation, chaque cellule est identifiable à l'aide d'un seul numéro. On peut récupérer le numéro de
	la cellule sur laquelle se trouve notre poireau à l'aide de la fonction <a href='documentation/getCell'><b>getCell</b></a> :
fight_ground_4			var maCase = getCell(); // On récupère le numéro de notre cellule
fight_ground_5			Contenu d'une cellule
fight_ground_6			Grâce à la fonction <a href='documentation/getCellContent'><b>getCellContent</b></a>, on peut déterminer le contenu d'une cellule :
	est-ce qu'un poireau se trouve dessus, ou bien un obstacle, ou est-elle vide ?
fight_ground_7			var cell = ...; // une cellule quelconque
						var content = getCellContent(cell);
						if (content == CELL_EMPTY) {
							// la cellule est vide
						} else if (content == CELL_OBSTACLE) {
							// la cellule est un obstacle
						} else if (content == CELL_LEEK) {
							// la cellule contient un poireau
						}
fight_ground_8			Si la cellule contient un poireau, on peut récupérer l'id de ce poireau grâce à la fonction
	<a href='documentation/getLeekOnCell'><b>getLeekOnCell</b></a> :
fight_ground_9			var cell = ...; // une cellule
						if (getCellContent(cell) == CELL_LEEK) {
							var leek = getLeekOnCell(cell); // on récupére l'id du poireau
							if (isEnemy(leek)) {
								say("C'est un ennemi !");
							}
						}
fight_intro			Nous allons maintenant voir comment réellement combattre dans <b>Leek Wars</b>, en expliquant le système de combat,
	puis comment programmer un bon comportement.
fight_move			Les déplacements et Points de Mouvement (PM)
fight_move_1			Se déplacer peut s'avérer utile en combat. Votre poireau possède un nombre fixé de points de mouvements (3 au niveau 1).
Un PM équivaut à une cellule, plus vous aurez de PM, plus vous pourrez
	vous déplacer loin sur le terrain.
	Pour ce faire, de nombreuses fonctions sont à notre disposition. Elles sont principalement
	de deux sortes : avancer et reculer, vers des cibles diverses.
fight_move_10			Si notre cible n'est pas un poireau précis mais une cellule ou un groupe de cellules, les fonctions à utiliser seront :
	<a href='documentation/moveTowardCell'><b>moveTowardCell</b></a> et
	<a href='documentation/moveAwayFromCell'><b>moveAwayFromCell</b></a>, pour une seule cellule,
	et <a href='documentation/moveTowardCells'><b>moveTowardCells</b></a> et
	<a href='documentation/moveAwayFromCells'><b>moveAwayFromCells</b></a>, pour un groupe de cellules.
fight_move_11			Une ligne comme cible
fight_move_12			On peut également avancer ou reculer vers une ligne de cellules. Une ligne de cellules est définie par deux cellules appartenant
	à cette ligne. Par exemple, si un ennemi en face de nous possède une arme de type laser, qui tire en ligne,
	on peut chercher à fuir cette ligne qui semble dangereuse :
fight_move_13			var enemy = ...; // l'ennemi en question
						var saCellule = getCell(enemy);
						var maCellule = getCell();
						moveAwayFromLine(saCellule, maCellule);
fight_move_2			Un ou des poireau(x) comme cible
fight_move_3			On peut s'approcher ou s'éloigner d'un poireau (allié ou ennemi) grâce aux fonctions
	<a href='documentation/moveToward'><b>moveToward</b></a> et <a href='documentation/moveAwayFrom'><b>moveAwayFrom</b></a> respectivement :
fight_move_4			var enemy = getNearestEnemy();
						if (getLife() > 100) {
							moveToward(enemy); // on se rapproche
							// attaque...
						} else {
							moveAwayFrom(enemy); // on s'éloigne
							// soins...
						}
fight_move_5			Ces fonctions utilisées tel quel vont utiliser le nombre de points de mouvements variable, un nombre de telle sorte à accomplir au
	mieux leur objectif. Ainsi, si vous êtes à une très grande distance d'un ennemi, <b>moveToward</b> utilisera sans doute tous vos PM,
	alors que si vous êtes collé à cet ennemi, elle n'en utilisera aucun.
fight_move_6			Pour mieux contrôler le nombre de PM qu'une fonction utilise, vous pouvez spécifier le nombre de PM maximum, en deuxième paramètre :

fight_move_7			var enemy = getNearestEnemy();
						moveToward(enemy, 3); // on avance vers l'ennemi, de 3 cellules max.
						useWeapon(enemy); // on essaye de lui tirer dessus
						moveAwayFrom(enemy); // on s'éloigne, d'un nombre illimité de cellules
fight_move_8			Ces fonctions existent aussi quand notre cible n'est pas un mais plusieurs poireaux :
	fonctions <a href='documentation/moveTowardLeeks'><b>moveTowardLeeks</b></a> et
	<a href='documentation/moveAwayFromLeeks'><b>moveAwayFromLeeks</b></a>, pour s'approcher ou s'éloigner d'un groupe de poireaux.

fight_move_9			Une ou des cellule(s) comme cible
fight_speak			Parler
fight_speak_1			Votre poireau peut parler pendant le combat, pour encourager ses alliés, ou bien narguer ses ennemis.
	La fonction pour faire parler votre poireau est <a href='documentation/say'><b>say</b></a>, et coûte <b>1 PT</b> :
fight_speak_2			say("Vous allez tous finir en soupe !"); // narguer l'équipe adverse
fight_sys			Le système de combat
fight_sys_1			Il faut tout d'abord parler du système de combat de <b>Leek Wars</b>. Les combats sont des matchs à mort par équipe,
	pour remporter la victoire, chaque poireau de l'équipe adverse doit être éliminé (vie à zéro).
fight_sys_10			La fonction <b><a href='documentation/getNearestEnemy'>getNearestEnemy()</a></b> elle, renvoie l'id du poireau le plus proche de vous. Récupérer l'id d'un poireau ennemi va
	servir à l'attaquer principalement.
fight_sys_11			var enemy = getNearestEnemy(); // On récupère l'id de l'enemi le plus proche
useWeapon(enemy); // On lui tire dessus
fight_sys_12			La fonction <b><a href='documentation/getEnemies'>getEnemies()</a></b> renvoie elle les poireaux ennemis (vivants ou morts) dans
	le combat.
fight_sys_13			var enemies = getEnemies(); // On récupère un tableau des ids des ennemis
						var n = 0;
						for (var enemy in enemies) { // On parcourt tous les ennemis
							if (getLife(enemy) > 1000) { // getLife(enemy) renvoie la vie du poireau
								n++;
							}
						}
						debug(n + " ennemis ont plus de 1000 PV");
fight_sys_2			Ordre de jeu
fight_sys_3			Les poireaux jouent <b>chacun leur tour</b>. L'ordre est déterminé par la fréquence des poireaux, mais on alterne toujours
	entre les deux équipes : le poireau qui	a la plus grande fréquence a plus de chances de commencer et faire commencer son équipe, et le deuxième poireau
	à jouer est celui qui a la plus grande fréquence dans l'autre équipe, et ainsi de suite.
fight_sys_4			Le combat est divisé en tours : quand le dernier poireau a joué, on repasse au premier et le compteur de tours s'incrémente.
	Pour éviter des combats infinis, le nombre de tours est limité à <b>64</b> (constante <a href='documentation/MAX_TURNS'>MAX_TURNS</a>).
	Quand le compteur atteint cette limite, le combat se solde par une égalite. Lors d'un combat qui dure longtemps,
	il faudra donc bien veiller à surveiller le compteur de tours. La fonction
	<b><a href='documentation/getTurn'>getTurn()</a></b> donne le tour actuel du combat :
fight_sys_5			var turn = getTurn();
					if (turn > 60) {
						// Le combat va bientot se terminer, il faut se dépêcher de finir...
					}
fight_sys_6			Une numérotation des joueurs
fight_sys_7			Chaque poireau possède un code unique numérique (appelé aussi <b>id</b>, pour identifiant), qui permet de le désigner.
fight_sys_8			La fonction <b><a href='documentation/getLeek'>getLeek()</a></b> renvoie l'id de votre poireau. Récupérer votre id est utile par exemple pour utiliser une puce
	de soin sur vous-même.
fight_sys_9			var moi = getLeek(); // On récupère l'id de notre poireau
					useChip(CHIP_CURE, moi); // On lance la puce "Guérison" sur nous
fight_weapons			Les armes
fight_weapons_1			Prendre une arme
fight_weapons_2			Prendre une arme est en général la première chose à faire dans un combat. Pour ce faire, il faut équiper l'arme sur
	votre poireau (bouton "Modifier" sur la page du poireau), puis utiliser la fonction
	<a href='documentation/setWeapon'><b>setWeapon</b></a>, par exemple :
fight_weapons_3			// On prend le pistolet
						setWeapon(WEAPON_PISTOL);
fight_weapons_4			Attention ! La fonction <b>setWeapon</b> coûte 1 PT.
fight_weapons_5			Utiliser une arme
fight_weapons_6			Maintenant que votre poireau possède une arme, il ne reste plus qu'à attaquer avec. Pour cela, il faut utiliser
	la fonction <a href='documentation/setWeapon'><b>useWeapon</b></a> :
fight_weapons_7			var enemy = getNearestEnemy();
						useWeapon(enemy); // attaque
fun_1			Le LeekScript permet la création de fonctions personnelles qui vont vous permettre d'organiser et de simplifier votre
	IA. Si vous avez écrit une opération complexe et souhaitez la réutiliser un certain nombre de fois dans votre code,
	l'utilisation d'une fonction sera la meilleure solution.
fun_10			Dans le corps de la fonction, on observe le mot-clé <b>return</b> suivit de la formule de l'hypothénuse.
	Ce mot-clé va renvoyer la valeur de l'expression situé à sa droite, ici l'hypothénuse avec comme longueurs des côtés <i>x</i>
	et <i>y</i>.
fun_11			On peut utiliser notre fonction <i>hypot</i> dans notre code de la manière suivante :
fun_12			var a = 4;
				var b = 3;
				var c = hypot(a, b); // c prend la valeur sqrt(4 * 4 + 3 * 3) soit 5
fun_13			On peut entièrement réécrire le code d'exemple en utilisant notre fonction :
fun_14			// Définition de la fonction hypot
				function hypot(x, y) {
					return sqrt(x * x + y * y);
				}

				var a = 3;
				var b = 4;
				var c = hypot(a, b);
				a = hypot(b, c) + hypot(c, 4);
				b = hypot(a, c);
fun_15			Nous avons gagné en lisibilité et réduit la taille du code.
fun_16			On notera que la fonction <i>hypot</i> existe déjà dans les fonctions prédéfinies du LeekScript (voir la fonction
	<a href='documentation/hypot'>hypot</a> dans la documentation).
fun_17			Return sans valeur
fun_18			Le mot clé <b>return</b> peut être utilisé sans expression à sa droite, la fonction renverra dans ce cas là une valeur
	<b>null</b>.
fun_19			Exemple de <b>return</b> sans valeur :
fun_2			Une fonction basique
fun_20			function logarithme(n) {
					if (n <= 0) {
						return;
					}
					// reste du calcul...
				}
fun_21			L'exécution de la fonction étant stoppée au premier return rencontré, si n est inférieur ou égal à 0,
	cette fonction renverra <b>null</b> puis n'effectuera pas le reste du calcul :
fun_22			var a = logarithme(-5); // a va prendre la valeur null
fun_23			Récursivité
fun_24			Une fonction peut appeler une autre fonction, par exemple :
fun_25			function carre(x) {
					return x * x;
				}
				function hypot(x, y) {
					return sqrt(carre(x) + carre(y));
				}
				var a = hypot(3, 4); // a vaut sqrt(3 * 3 + 4 * 4)
fun_26			Ainsi, une fonction peut s'appeller elle-même :
fun_27			function factorielle(n) {
					if (n <= 1) return 1;
					return n * factorielle(n - 1);
				}
fun_28			Cette fonction renvoie la factorielle du nombre n (n!) passé en paramètre (n! = n × (n - 1) × ... × 3 × 2 × 1).
	On constate qu'elle se contente de renvoyer n × (n - 1)!, ce qui est égal à n!
fun_29			<b>Attention !</b> Si une fonction s'appelle elle-même sans condition de sortie, ou que deux ou plusieurs fonctions
	s'appellent entre elles de manière cyclique, votre code va boucler à l'infini, et dans le cas du LeekScript, va atteindre
	la limite maximale de la pile, qui est fixée à <b>200</b>. Ainsi, avec une telle limite, votre code pourra
	calculer au maximum la factorielle de <i>200</i>.
fun_3			Nous allons prendre l'exemple d'un code qui calcule l'hypothénuse d'un triangle rectangle, de côtés de longueur
	<i>a</i>, <i>b</i> et <i>c</i>. Si le côté de longueur <i>c</i> est l'hypoténuse, et si <i>a</i> et <i>b</i> sont connus,
	<i>c</i> peut s'obtenir avec le code suivant :
fun_30			Exemples de codes menant à une surcharge de la pile :
fun_31			function mauvaiseFactorielle(n) {
					return n * mauvaiseFactorielle(n);
				}
				var a = mauvaiseFactorielle(5);
				// le code boucle à l'infini et se stoppe à 200 appels
fun_32			function a() {
					b();
				}
				function b() {
					a();
				}
				a(); // a et b s'appellent entre elles en boucle
fun_33			Niveau des fonctions
fun_34			Dans le LeekScript, certaines fonctions ont un niveau minimum. Le poireau sur lequel l'IA sera équipée
	devra donc avoir les conditions requises. Exemple : la fonction <b><a href='documentation/getPathLength'>getPathLength</a></b>
	exige le niveau <b>37</b> :
fun_35			Niveau d'une fonction
fun_36			Aller plus loins dans les fonctions
fun_37			En LeekScript, chaque fonction peut être utilisée comme une variable :
fun_38			var variable = getLeek;
fun_39			Cela fonctionne aussi bien avec les fonctions de base du LeekScript qu'avec celles que vous définissez dans votre code. Pour utiliser une fonction dans une variable il faut l'appeler comme une fonction classique :
fun_4			var c = sqrt(a * a + b * b);
fun_40			var variable = getLeek;

				variable(); // Revient à utiliser getLeek
fun_41			On peut par exemple donner une fonction en paramètre :
fun_42			function ma_fonction(parametre) {
					debug(parametre());
				}

				ma_fonction(getLeek);
fun_43			Le LeekScript propose également un type de fonction un peu particulier appelé "fonction anonyme", il s'agit de fonctions sans nom, déclarées directement dans une expression.
fun_44			Cela permet une écriture plus simple, et évite de déclarer une fonction lorsque ce n'est pas utile. Pour déclarer une fonction anonyme, il faut utiliser le mot clé function et directement ouvrir la parenthèse permetant de définir les paramètres, sans préciser de nom.
fun_45			var ma_fonction = function() { return "Test"; };
fun_46			Pour utiliser une fonction anonyme, c'est exactement comme utiliser une fonction que l'on aurait mise dans une variable :
fun_47			var ma_fonction = function() { return "Test"; };

				ma_fonction();
fun_48			Si par exemple on a une fonction qui prend en paramètre une autre fonction, on peut lui passer directement une fonction anonyme, comme par exemple :
fun_49			function arrayMap(tableau, fonction) {
					var r = [];
					for (var v in tableau) push(r, fonction(v));
					return r;
				}

				var t = arrayMap([1, 2, 3, 4, 5], function(x) { return x ** 2; });

				debug(t); // [1, 4, 9, 16, 25]
fun_5			Imaginons maintenant que cette formule est utilisée de nombreuses fois dans votre code :
fun_50			La fonction arrayMap prend un tableau et une fonction et retourne un nouveau tableau constitué de chaque élément du tableau d'entrée auquel on a appliqué la fonction.
fun_6			var a = 3;
				var b = 4;
				var c = sqrt(a * a + b * b);
				a = sqrt(b * b + c * c) + sqrt(c * c + 4 * 4);
				b = sqrt(a * a + c * c);
fun_7			On remarque qu'il est fastidieux de recopier sans cesse la même formule, tout en compliquant de manière importante notre
	code. <br />
	On va donc créer une fonction <i>hypot</i> qui va directement calculer l'hypoténuse. Cette fonction est définie par le code
	suivant :
fun_8			function hypot(x, y) {
					return sqrt(x * x + y * y);
				}
fun_9			Analysons ce code. Pour déclarer une fonction, on utilise le mot-clé <b>function</b>, on note ensuite le nom de
	la fonction, ici <i>hypot</i>. On écrit ensuite entre parenthèses la liste des paramètres, séparés par des virgules, ici "x" et "y".
	Le corps de la fonction est ensuite entre accolades.
functions			Les fonctions
interface			L'interface
intro			<b>LeekScript</b> est le langage de programmation dedié à la création d'intelligences artificielles pour poireau. Sa syntaxe est très proche du Javascript et ne devrait pas perturber les adeptes de la programmation en C, Java ou même PHP. Si vous débutez totalement en la matière ou souhaitez connaître certaines subtilités du <b>LeekScript</b>, ce tutoriel est fait pour vous :)
loops			Les boucles
loops_1			Nous allons maintenant nous intéresser un autre type de structure tout aussi fondamental que les conditions :
	les boucles !
loops_10			La boucle <b>do while</b> est similaire à la boucle <b>while</b>, excepté que la condition se situe à la fin, le corps de la boucle est donc éxécuté toujours au moins une fois :
loops_11			var x;
					do {
						x = rand(); // x est un nombre aléatoire entre 0 et 1
					} while (x < 0.8); // on répète tant que x n'est pas supérieur à 0.8

					debug("x : " + x); // affiche un nombre entre 0.8 et 1
loops_12			La boucle for
loops_13			Un autre type de boucle un petit peu plus complexe existe, il ressemble à une boucle while mais en plus condensé.
	Vous verrez à l’usage que selon les cas d’utilisation il est plus pratique d’utiliser un <b>for</b> ou un while.
loops_14			La boucle <b>for</b> se compose de trois parties :
loops_15			L’initialisation : l’assignation d’une valeur de départ à une variable “compteur”
loops_16			La condition : tant qu’elle est valide la boucle continue de s’exécuter
loops_17			L’incrémentation : faire augmenter (ou diminuer selon le cas) la valeur de votre variable “compteur”
loops_18			Exemple de boucle <b>for</b> :
loops_19			var i;
					// On fait une boucle de i = 1 tant que i est inférieur ou égal à 5
					// et on incrémente i à chaque tour de boucle
					for (i = 1; i <= 5; i++) {
						debug("Le compteur i vaut : " + i);
					}
loops_2			La boucle permet de répéter des instructions plusieurs fois. Il y a plusieurs types de boucles. Nous allons les voir dans
	cette partie.
loops_20			Ce code affichera dans les logs :<br />
	Le compteur i vaut 1<br />
	Le compteur i vaut 2<br />
	Le compteur i vaut 3<br />
	Le compteur i vaut 4<br />
	Le compteur i vaut 5
loops_21			Il est possible de déclarer le compteur dans l’initialisation de la boucle for en mettant le mot clé var
	devant le nom de variable :
loops_22			for (var i = 1; i <= 5; i++) {
						// Instructions...
					}
loops_23			Il existe une autre variante de boucle for, la structure : <b>for</b> ... <b>in</b>, qui permet de boucler sur les valeurs d'un
		tableau directement.
		Un exemple :
loops_24			var tableau = [1,1,2,3,5,8,13,21];
					for (var valeur in tableau) {
						debug(valeur);
					}
loops_25			Le code affichera successivement toutes les valeurs du tableau : 1,1,2,3,5,8,13,21.
loops_26			Si vous souhaitez aussi récupérer la clé associée à chaque valeur du tableau, vous pouvez utiliser le <b>for</b> ...
	<b>in</b> en ajoutant :
loops_27			for (var cle : var valeur in tableau) {
						debug("clé " + cle + " => " + valeur);
					}
loops_3			La boucle while
loops_4			La boucle while (tant que) a une syntaxe similaire au if vu dans le chapitre
				précédent. Elle permet d’exécuter un bloc d’instruction tant qu’une condition
				est remplie.
loops_6			Voici un exemple :
loops_7			// On déclare un compteur qu’on initialise à 0
				var compteur = 0;
				while (compteur < 5) { // Tant que le compteur est inférieur à 5
					compteur = compteur + 1;
					debug("Compteur vaut " + compteur);
				}
loops_8			Ce code affichera dans les logs lors de son exécution : <br />
	Compteur vaut 1<br />
	Compteur vaut 2<br />
	Compteur vaut 3<br />
	Compteur vaut 4<br />
	Compteur vaut 5
loops_9			La boucle do while
menu			Menu
presentation			Présentation
presentation_1			<b>Leek Wars</b> vous permet d’élever vos poireaux, de leur faire équiper des armes, des puces (sortes de sorts),
	et de programmer leur propre intelligence artificielle afin de les faire combattre contre les poireaux des
	autres éleveurs !
presentation_2			Pour bien commencer, nous allons dans un premier temps voir comment équiper une arme ou une puce sur votre poireau
	afin qu’il puisse participer sans encombre à des combats.
test_config			La configuration du test
the_documentation			La documentation
title			Tutoriel
var_1			Qu’est ce qu’une variable ?
var_10			Pour utiliser une variable, il est nécessaire de la déclarer au préalable. Cette déclaration se fait en utilisant
	le mot clé “var” de la manière suivante :
var_11			// On déclare la variable nomDeVariable
				var nomDeVariable;
var_12			Il est également possible d’attribuer une valeur à votre variable de la manière suivante :
var_13			// On déclare la variable nomDeVariable et on lui assigne la valeur 12
				var nomDeVariable = 12;
var_14			À noter qu’on peut également déclarer plusieurs variables en les séparant par une virgule :
var_15			// Déclaration de premiereVariable et deuxiemeVariable
				var premiereVariable, deuxiemeVariable;
var_16			Attention à ne pas oublier le point-virgule <b>;</b> à la fin de l’instruction.
var_17			Les variables déclarées avec le mot clé var ont comme durée de vie le tour de votre poireau,
				il existe un second type de variable qui gardent leur valeur durant toute la durée du combat : les variables globales.
				Pour déclarer une variable globale, il suffit d’utiliser le mot-clé “global” au lieu de “var” :
var_18			// Déclaration d’une variable globale
				global nomDeGlobale;
var_19			Il est également possible d’assigner une valeur à une globale lors de sa déclaration :
var_2			Les variables sont un point fondamental dans tous les langages de programmation. Elles permettent de garder
    			en mémoire des valeurs afin de les réutiliser dans des calculs.
var_20			// Déclaration de la variable globale nomDeGlobale, de valeur 42
				global nomDeGlobale = 42;
var_21			Les variables et variables globales peuvent s’utiliser de la même manière dans le code, dans la suite
				du tuto nous utiliserons principalement des variables normales (parfois appelées locales).
var_22			Utilisation des variables
var_23			Il est possible d’utiliser les variables dans votre code de différentes façons.
var_24			On peut leur assigner une valeur (c’est à dire leur faire “retenir” cette valeur en mémoire) en utilisant
	l’opérateur d’assignation <b>=</b> :
var_25			// On déclare maVariable
				var maVariable;
				// On assigne 1 à maVariable
				maVariable = 1;
var_26			Il est possible d’effectuer des calculs écrivant des expressions, vous pouvez utiliser les opérateurs suivants :
var_27			+ : addition
var_28			- : soustraction
var_29			* : multiplication
var_3			Les variables proposées par le LeekScript peuvent contenir plusieurs types de valeur
var_30			/ : division
var_31			% : modulo (reste d’une division euclidienne)
var_32			On procède ainsi :
var_33			// Déclaration de la variable a
				var a;
				// On effectue quelques calculs
				a = 2 + 8; // a prend la valeur 10
				a = 5 - 4; // a prend la valeur 1
				a = 3 * 5; // a prend la valeur 15
				a = 6 / 2; // a prend la valeur 3
				a = 8 % 3; // a prend la valeur 2

				// Mais on peut également combiner les opérateurs
				a = 1 + 2 * 3; // a prend la valeur 7
				a = 4 / 2 + 1; // a prend la valeur 3

				// Et même utiliser des parenthèses
				a = (2 + 3) * 2; // a prend la valeur 10
var_34			On peut également utiliser une variable dans une expression, sa valeur sera utilisée pour
				effectuer le calcul. Par exemple :
var_35			// Déclaration de la variable a et b
				var a, b;

				// On assigne la valeur 10 à a
				a = 10; // a prend la valeur 10

				// On assigne la valeur a + 5 à b
				b = a + 5; // b prend la valeur 15
var_36			On peut également utiliser des chaînes de caractères de la manière suivante :
var_37			var maVariable;
				maVariable = "Je suis une chaîne de caractères";
var_38			Pour une chaîne de caractère, seul l’opérateur <b>+</b> est utilisable, il permet de concaténer des morceaux
				de chaîne, c’est à dire de les mettre bout à bout. Comme le montre le code :
var_39			// Déclaration de chaine1 et chaine2
				var chaine1, chaine2;

				chaine1 = "Bonjour "; // chaine1 prend la valeur "Bonjour "
				chaine2 = chaine1 + " tout le monde"; // chaine2 vaut "Bonjour tout le monde"
var_4			Chaîne de caractères
var_40			Il est intéressant de noter qu’on peut concaténer une chaîne avec un nombre, cela peut être utile
				pour inclure le résultat d’un calcul dans une chaîne :
var_41			// Déclaration de a et chaine
				var a, chaine;

				a = 51 * 17; // a prend la valeur 867
				chaine = "Multiplier 51 et 17 donne la valeur : " + a;
				// chaine contient alors "Multiplier 51 et 17 donne la valeur : 867"
var_42			Un bon réflexe en LeekScript
var_43			Ce que nous allons voir maintenant est un outil qui va vous être très utile dans le développement de votre IA,
				il s’agit d’une fonction vous permettant d’afficher la valeur de variable ou d’expressions.
var_44			Nous n’avons pas encore vu comment utiliser de fonction et nous expliqueront leur mécanisme plus en détail un peu plus
				loin dans ce cours, pour le moment nous allons juste apprendre à utiliser "debug".
var_45			<i>debug</i> est une fonction du LeekScript qui permet d’afficher dans les log de combat (il s’agit un peu d’une
				sortie standard).
				Vous pourrez donc en savoir un peu plus sur l’exécution de votre script.
				Nous allons apprendre à l’utiliser.
var_46			Rendez vous dans l’éditeur et créez une nouvelle IA, mettez y le code suivant :
var_47			debug("Je suis un texte de test");
var_48			Lancez un combat de test et faites “Quitter” (la petite croix en bas)  afin d’accéder directement au
				rapport de combat. Cliquez sur le sous onglet “Actions”, vous arrivez alors sur cette page :
var_49			La fonction debug() en action
var_5			Nombre
var_50			Cette page récapitule toutes les actions du combat, vous pouvez remarquer qu’à chaque début de votre tour,
				une ligne : “[VotrePoireau] Je suis un texte de test” apparaît.
var_51			A chaque fois que la fonction <i>debug</i> est appelée, la valeur fournie en paramètre est ajoutée dans les logs dans la
				chronologie du combat, vous pouvez donc voir à quel moment du combat s’execute l’instruction.
				Vous pouvez afficher la valeur d’une variable, le résultat d’un calcul...
var_52			// Affichage d’un texte simple
				debug("Texte simple"); // Affiche : [VotrePoireau] Texte simple
				debug(5 + 6); // Affiche : [VotrePoireau] 11

				var a = 5;
				debug(a); // Affiche : [VotrePoireau] 5
				debug("Valeur de a : " + a); // Affiche : [VotrePoireau] Valeur de a : 5
var_53			Cette fonction peut vous faire gagner un temps précieux lorsque vous avez un bug dans votre code donc
				n’hésitez pas à l’utiliser.<br>
				A noter que vous ne pouvez voir que les messages de debug de vos poireaux (et inversement, vos adversaires ne pourront
				pas voir vos messages de debug)
var_6			Booléen (vrai ou faux)
var_7			Tableau (nous y reviendrons un peu plus loin)
var_8			null
var_9			Cependant le type de la variable n’est pas fixe (comme en C ou en Java) mais s'adapte aux données que
				l’on souhaite y stocker (comme en JavaScript ou en PHP).
variables		Les variables
welcome			Bienvenue dans le tutoriel LeekScript !
what_is_ai		Qu’est-ce qu’une IA ?
what_is_ai_1	Une <b>Intelligence Artificielle</b> (<b>IA</b>) est un code en <i>LeekScript</i> qui va contrôler votre poireau durant son tour de jeu.
				Le code que vous allez créer sera exécuté à chaque début de tour de votre poireau, il contrôlera les actions que votre
				poireau va effectuer (attaquer, se déplacer, utiliser une puce…).
what_is_ai_2	Lorsqu’un combat est lancé, vous ne pouvez plus intervenir sur les actions de votre protégé: seule l’IA est prise en compte,
				c’est pourquoi il est primordial de la programmer avec soin.
what_is_ai_3	Nous allons maintenant voir l’environnement proposé par <b>Leek Wars</b> pour développer votre IA.
what_is_leekscript			Qu’est ce que le LeekScript ?
what_is_leekscript_1		Maintenant que vous avez une arme, nous allons pouvoir nous pencher sur la partie création d'intelligences
							Artificielle (IA) qui est le sujet de ce tutoriel. <b>Leek Wars</b> vous propose de programmer vos IA dans un langage
							appelé le LeekScript, il s’agit d’un langage proche du Javascript et du PHP, non typé et non orienté objet.
what_is_leekscript_2			Le langage est facile à utiliser et à apprendre. Il met à votre disposition des fonctions puissantes qui vous
	permettront de créer une IA efficace même si vous débutez. A l’inverse, si vous êtes déjà expérimentés en
	programmation, des fonctions plus poussées vous permettrons de créer des IA plus sophistiquées.
