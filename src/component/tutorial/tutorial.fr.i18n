{
	"advanced": "Avancé",
	"advanced_include": "Les inclusions",
	"advanced_include_1": "La fonction <b>include</b> permet d'inclure une IA dans une autre. Concrètement, si dans une IA \"IA Principale\", vous écrivez :",
	"advanced_include_10": "// ne fonctionne pas\nvar ias = ['IA_1', 'IA_2', 'IA_3'];\nfor (var ia in ias) {\n\tinclude(ia);\n}",
	"advanced_include_11": "Pourquoi ?",
	"advanced_include_12": "La raison est que le compilateur du LeekScript réalise les inclusions à la compilation uniquement. L'inclusion d'une IA à l'exécution (exemple : si l'ennemi est proche de moi, inclure \"IA_Fuite\") n'est pas supporté. Les IA incluses dans les autres doivent être déterminées à la compilation, c'est pourquoi la seule façon d'include une ia est :",
	"advanced_include_13": "// Fonctionne\ninclude(\"chaine_de_caractères\");",
	"advanced_include_2": "include(\"Fonctions\");",
	"advanced_include_3": "Le contenu de l'IA se nommant \"Fonctions\" est recopié dans l'IA \"IA Principale\", ce qui vous permet de séparer différentes parties de votre code dans différentes IA.\nUn exemple : avoir une IA principale, appelée \"IA Principale\", une IA \"Déplacement\" contenant plusieurs fonctions complexes pour se déplacer, une IA \"attaque\" contenant des fonctions utiles pour attaquer, une IA \"Paroles\", avec des fonctions permettant de parler etc.",
	"advanced_include_4": "Séparer son code par thème dans différentes IAs, des modules, permet de les réutiliser plus facilement ensuite. Si vous avez deux poireaux, il vous suffit de faire deux IA incluant toutes les deux les\ndifférents modules, sans devoir recopier le code dans les deux IA.",
	"advanced_include_5": "Limites de la fonctions include",
	"advanced_include_6": "L'utilisation de la fonction include est limitée en LeekScript, en effet il est impossible d'inclure dynamiquement une autre IA. Les codes ci-dessous ne fonctionnent pas :",
	"advanced_include_7": "// ne fonctionne pas\ninclude(\"IA_\" + 5);",
	"advanced_include_8": "// ne fonctionne pas\nvar ia = 'IA_1';\ninclude(ia);",
	"advanced_include_9": "// ne fonctionne pas\nif (foo > 12) {\n\tinclude('IA_1');\n} else {\n\tinclude('IA_2');\n}",
	"advanced_intro": "Dans cette section nous présenterons des fonctions et techniques plus complexes mais néanmoins utiles pour gagner un combat\ndans <b>Leek Wars</b>.",
	"advanced_order": "Ordre de jeu",
	"advanced_order_1": "Les fonctions <a href='documentation/getNextPlayer'><b>getNextPlayer</b></a>\n(resp. <a href='documentation/getPreviousPlayer'><b>getPreviousPlayer</b></a>) permettent de récupérer l'id du poireau qui\nva jouer (resp. a joué) après (resp. avant) vous.\nUne application possible : regarder si le joueur qui joue après vous (un ennemi) est proche de vous.",
	"advanced_order_2": "var next = getNextPlayer();\nif (isEnemy(next) and getLife() < 100\n\tand getCellDistance(getCell(), getCell(next)) < 10) {\n\t// On est en danger, le prochain joueur est un ennemi, proche\n}",
	"advanced_order_3": "Cibles d'une arme ou d'une puce",
	"advanced_order_4": "Les fonctions <a href='documentation/getWeaponTargets'><b>getWeaponTargets</b></a> et\n<a href='documentation/getChipTargets'><b>getChipTargets</b></a> permettent de récupérer un tableau d'id des poireaux touchés\nsi vous utilisez une arme ou une puce sur une certaine cellule. Particulèrement utiles pour les armes ou puces de zone (aussi bien\nun lance-grenades qu'un sort de soin en zone) :",
	"advanced_order_5": "var cell = ...; // une cellule\nvar targets = getChipTargets(CHIP_ICEBERG, cell);\nif (count(targets) > 1) { // on touche plus d'un joueur en lançant ici\n\tfor (var target in targets) {\n\t\tif (isAlly(target)) {\n\t\t\t// On touche un allié, pas bon :/\n\t\t}\n\t}\n}",
	"advanced_ref": "Le passage par référence",
	"advanced_ref_1": "Quand vous écrivez une fonction en LeekScript, vous pouvez lui préciser des arguments, par exemple :",
	"advanced_ref_2": "function somme(a, b, resultat) {\n\tresultat = a + b;\n}",
	"advanced_ref_3": "Quand vous allez appeler cette fonction, les variables que vous lui passez seront <b>copiées</b>, c'est à dire que si vous faites :",
	"advanced_ref_4": "function somme(a, b, resultat) {\n\tresultat = a + b;\n}\n\nvar a = 2;\nvar b = 10;\nvar resultat = 0;\n\nsomme(a, b, resultat);\ndebug(resultat);",
	"advanced_ref_5": "Ici, le programme affichera 0, car la variable resultat vaudra 0. Quand vous passez ces 3 variables (a, b et resultat) dans la fonction \"somme\",\nleurs valeurs sont recopiées pour être utilisées à l'intérieur. Ainsi, les valeurs 2, 10 et 0 sont envoyées. L'opération \"resultat = a + b\" travaille donc avec des copies des valeurs, et ne va pas affecter votre variable \"resultat\".",
	"advanced_ref_6": "Il est possible de résoudre le problème en passant \"resultat\" par référence. Pour ce faire, il suffit de rajouter un \"@\" devant son nom dans la liste des arguments de la fonction :",
	"advanced_ref_7": "function somme(a, b, @resultat) {\n\tresultat = a + b;\n}\n\nvar a = 2;\nvar b = 10;\nvar resultat = 0;\n\nsomme(a, b, resultat);\ndebug(resultat); // \"resultat\" vaut bien 12.",
	"advanced_tern": "Les ternaires",
	"advanced_tern_1": "Les ternaires sont un moyen plus rapide d'écrire une condition. La structure d'une condition ternaire est :",
	"advanced_tern_2": "condition ? valeur_si_vrai : valeur_si_faux",
	"advanced_tern_3": "Ainsi, on peut remplacer :",
	"advanced_tern_4": "if (getCell() == 42) {\n\tuseWeapon(getNearestEnemy());\n} else {\n\tmoveTowardCell(42);\n}",
	"advanced_tern_5": "par le code suivant :",
	"advanced_tern_6": "(getCell() == 42) ? useWeapon(getNearestEnemy()) : moveTowardCell(42);",
	"advanced_tern_7": "Les deux codes si-dessus sont équivalents. Les ternaires permettent de condenser son code pour des conditions simples,\nmais attention néanmoins à ne pas en abuser, cela pourrait rendre votre code difficilement lisible.",
	"advanced_triple_equal": "L'opérateur ===",
	"advanced_triple_equal_1": "L'opérateur <b>===</b> permet de comparer deux valeurs, ainsi que leur type. Il est plus restrictif que l'opérateur <b>==</b>.",
	"advanced_triple_equal_2": "<tr><th>Opérateur</th><th>Description</th></tr>\n<tr><td>===</td><td>Vérifie si les deux opérandes sont de même valeur et de même type</td></tr>\n<tr><td>!==</td><td>Vérifie si les deux opérandes ne sont pas de même valeur ou ne sont pas de même type</td></tr>",
	"advanced_triple_equal_3": "Le fonctionnement de l'opérateur <b>===</b> est très simple :",
	"advanced_triple_equal_4": "Celui de <b>==</b>, en revanche, est plus complexe, car il tente d'effectuer certaines conversions :",
	"advanced_triple_equal_5": "Le fonctionnement global du <b>==</b> est de convertir les valeurs quand ces deux dernières ne sont pas de même type, par exemple, \"true\" == 1,\n\"lama\" == true, 12 == true, mais, 1 != 12 et \"true\" != \"lama\". Quand les deux valeurs sont de même type, le <b>==</b> a le même comportement que <b>===</b>.",
	"advanced_triple_equal_6": "Quand le <b>==</b> compare un tableau a un seul élément, ce tableau est assimilé à cet élément. Par exemple, 1 == [1], \"1\" == [\"1\"], et par conséquent \"1\" == [1] et 1 == [\"1\"]. Par récusivité, on a également 1 == [[1]], 1 == [[[1]]] etc.",
	"advanced_triple_equal_7": "L'opérateur <b>==</b> est donc à utiliser avec précaution, si vous souhaitez être sûr du test d'égalité entre les deux valeurs, utilisez <b>===</b>.",
	"arr_1": "Il y a un autre type de variable que nous avons rapidement évoqué tout à l’heure : les tableaux.\nJusqu’à présent, les variables que nous avons vues ont toutes un nom et une valeur, les tableaux ont\négalement un nom, mais il est possible de leur associer plusieurs valeurs, elles sont alors rangées dans des “cases”.",
	"arr_10": "Dans les deux cas le tableau obtenu peut être représenté ainsi :",
	"arr_11": "<tr><th>Indice</th><th>Valeur</th></tr>\n<tr><td>0</td><td>Poireau</td></tr>\n<tr><td>1</td><td>Lama</td></tr>\n<tr><td>2</td><td>Autruche</td></tr>\n<tr><td>3</td><td>Artichaut</td></tr>",
	"arr_12": "On peut accéder à une case d’un tableau en indiquant l’indice de la case à laquelle\non souhaite accéder entre crochets :",
	"arr_13": "// Déclaration du tableau\nvar monTableau = [\"Poireau\", \"Lama\", \"Autruche\", \"Artichaut\"];\ndebug(monTableau[1]); // Affichera Lama",
	"arr_14": "On peut utiliser une case d’un tableau exactement comme une variable normale :",
	"arr_15": "var monTableau = [2, 4, 6, 8];\ndebug(monTableau[0]); // Affiche 2\nmonTableau[0] = monTableau[1] + 5; // Assigne la valeur 9 à la case 0\ndebug(monTableau[0]); // Affiche 9",
	"arr_16": "Lorsqu’on concatène un tableau avec une chaîne de caractères ou qu’on tente de l’afficher avec la fonction debug,\non voit apparaître la liste de tous ses éléments, c’est très pratique pour le débugage.",
	"arr_2": "Les tableaux proposés pas le LeekScript sont des tableaux à indice (ou clé) numériques, vous pouvez y\nstocker n’importe quel type de valeur (y compris un autre tableau) ou encore y mettre un type différent\nd’une case à l’autre.",
	"arr_3": "Le premier indice d’un tableau sera toujours 0 et il est impossible d’utiliser des indices négatifs",
	"arr_4": "Pour créer un tableau, il faut utiliser la syntaxe suivante :",
	"arr_5": "// Déclaration d’un tableau\nvar monTableau = [];",
	"arr_6": "On peut remplir notre tableau de deux manières :<br />\nA l’initialisation :",
	"arr_7": "// Déclaration du tableau\nvar monTableau = [\"Poireau\", \"Lama\", \"Autruche\", \"Artichaut\"];",
	"arr_8": "Ou après l’initialisation, en utilisant des assignations :",
	"arr_9": "// Déclaration du tableau\nvar monTableau = [];\nmonTableau[0] = \"Poireau\";\nmonTableau[1] = \"Lama\";\nmonTableau[2] = \"Autruche\";\nmonTableau[3] = \"Artichaut\";",
	"arrays": "Les tableaux",
	"automatic_completion": "La complétion automatique",
	"buy_a_weapon": "Avant de faire combattre votre poireau, il est impératif de lui donner de quoi attaquer. Rendez vous dans\nl’onglet “Marché” afin d’acheter une arme. La page “Marché” se compose de deux sous-onglets : “Armes” et “Puces”.\nPour ce tutoriel nous allons acheter une arme mais le mécanisme est similaire pour une puce.",
	"buy_a_weapon_2": "Choisissez dans la liste l’arme qui vous plaît (et dont le niveau minimal est inférieur à celui de votre poireau),\ncliquez sur le bouton “Acheter”.",
	"buy_a_weapon_3": "Rendez vous ensuite dans l’onglet “Poireau”, en bas de cette page vous pouvez voir trois colonnes : Armes, Puces et IA.\nCliquez sur le lien “Modifier” de la colonne Armes, une petite fenêtre apparaît. Faites glisser votre arme de la\ncatégorie “Toutes les Armes” vers “Armes de [nom de votre poireau]”. Et voilà votre arme est équipée.",
	"cond_1": "Nous allons aborder un point important du LeekScript (et plus généralement de tout langage) : les conditions !<br />\nElles vous permettrons de faire exécuter des actions différentes à votre poireau selon les cas.",
	"cond_10": "Il est également possible de déterminer plusieurs cas, imaginons qu’on ait une valeur entre 0 et 10\net que l’on souhaite exécuter une action différente si cette valeur est entre 0 et 4, entre 5 et 7 ou entre 8 et 10.\nOn peut alors utiliser la structure else if (sinon si). Elle permet de définir une nouvelle condition et un nouveau groupe\nd’instructions.",
	"cond_11": "Exemple :",
	"cond_12": "var valeur = 5;\nif (valeur < 5) { // Si valeur est inférieur à 5 (entre 0 et 4 donc)\n\tdebug(\"Valeur est entre 0 et 4\");\n} else if (valeur < 8) { // Sinon si valeur est inférieur à 8 (entre 5 et 7)\n\tdebug(\"Valeur est entre 5 et 7\");\n} else { // Sinon (entre 8 et 10 donc)\n\tdebug(\"Valeur est entre 8 et 10\");\n}",
	"cond_13": "Nous allons maintenant voir quels sont les différents opérateurs de condition disponibles :",
	"cond_14": "<tr><th>Opérateur</th><th>Description</th></tr>\n<tr><td>==</td><td>Est égal à</td></tr>\n<tr><td>!=</td><td>Est différent de</td></tr>\n<tr><td>&lt;</td><td>Est inférieur à</td></tr>\n<tr><td>&lt;=</td><td>Est inférieur ou égal à</td></tr>\n<tr><td>&gt;</td><td>Est supérieur à</td></tr>\n<tr><td>&gt;=</td><td>Est supérieur ou égal à</td></tr>",
	"cond_15": "Il est également possible de combiner plusieurs conditions ensemble grâce aux opérateurs logiques :",
	"cond_16": "<tr><th>Opérateur</th><th>Description</th></tr>\n<tr><td>and</td><td>et</td></tr>\n<tr><td>or</td><td>ou</td></tr>",
	"cond_17": "Ce qui donne :",
	"cond_18": "var a = 1;\nvar b = 5;\nif (a < 5 and b > 6) { // Si a est inférieur à 5 et b est supérieur à 6\n\t// ...\n}\nif (a == 1 or a == 3) { // Si a est égal à 1 ou si a est égal à 3\n\t// ...\n}",
	"cond_19": "Il existe aussi l'opérateur <b>===</b>, qui permet de comparer la valeur et le type de deux valeurs, voir dans <a href='#triple_equals'>la section avancée</a>.",
	"cond_2": "Structure if… else…",
	"cond_20": "Quelques simplifications utiles",
	"cond_21": "Nous allons maintenant voir quelques simplifications au niveau des conditions qui vous permettront\nd’alléger votre code.",
	"cond_22": "Si vous ne voulez exécuter qu’une seule instruction dans votre bloc vous pouvez écrire directement\ncette instruction sans accolade :",
	"cond_23": "Pour un if par exemple :",
	"cond_24": "var a = 1;\nif (a == 1) debug(\"A est égal à 1\");",
	"cond_25": "Ou bien pour un if else :",
	"cond_26": "if (valeur > 5) debug(\"valeur supérieur à 5\")\nelse debug(\"valeur inférieure ou égale à 5\");",
	"cond_27": "Cette écriture permet de gagner un peu en lisibilité.",
	"cond_28": "Il est également possible d’écrire :",
	"cond_29": "var a = 1;\nif (a) debug(\"A est vrai\");",
	"cond_3": "Pour utiliser une condition, il faut écrire le mot clé if (si), une condition entre parenthèses,\npuis ouvrir une accolade, écrire les instructions à exécuter lorsque la condition est vérifiée, puis refermer l’accolade.",
	"cond_30": "Cette opération va vérifier si la valeur de a est vraie.",
	"cond_31": "Si a n'est pas un <b>booléen</b> :",
	"cond_32": "Si a est un <b>nombre</b>, toute valeur différente de 0 sera considérée comme vraie.",
	"cond_33": "Si a est une <b>chaîne de caractères</b>, a est vraie si elle est non vide.",
	"cond_34": "Si a est un <b>tableau</b>, a est vrai si il est non vide.",
	"cond_35": "Si a est <b>null</b>, a est faux.",
	"cond_4": "Voici un exemple :",
	"cond_5": "var a = 1;\nif (a < 10) { // On regarde si a est inférieur à 10\n\t// Si oui les instructions placées dans les accolades seront exécutées\n\tdebug(\"a est inférieur à 10\");\n}",
	"cond_6": "Dans cet exemple, a vaut 1 donc la condition est remplie, donc le debug sera executé et on aura\n\"a est inférieur à 10\" d’écrit dans les logs.",
	"cond_7": "Si on veut exécuter des instructions dans le cas où la condition est vérifiée et d’autres instructions\nquand elle ne l’est pas, il est possible d’utiliser le mot clé <b>else</b> (sinon) pour délimiter un second bloc.",
	"cond_8": "Exemple :",
	"cond_9": "var a = 1;\nif (a < 10) { // On regarde si a est inférieur à 10\n\t// Si oui les instructions placées dans les accolades seront exécutées\n\tdebug(\"a est inférieur à 10\");\n} else { // Sinon\n\t// Instructions à exécuter si a n’est pas inférieur à 10\n\tdebug(\"a n’est pas inférieur à 10\");\n}",
	"conditions": "Les conditions",
	"difficulty_child": "Enfant : 30 à 40% de vos caractéristiques (force, agilité, vie..) et 50% de vos PT et PM",
	"difficulty_easy": "Facile : 50 à 75% de vos caractéristiques et 80% de vos PT, PM",
	"difficulty_evil": "Diabolique : 200 à 250% de vos caractéristiques et 160% de vos PT, PM",
	"difficulty_hard": "Difficile : 130 à 160% de vos caractéristiques et 130% de vos PT, PM",
	"difficulty_medium": "Moyen : 95 à 110% de vos caractéristiques et 100% de vos PT, PM",
	"do_a_test_fight": "Faire un combat de test",
	"doc_1": "Un dernier point important à aborder avant de commencer ce cours est la documentation. Toutes les fonctions\net constantes disponibles dans le leekScript sont regroupées sur une page : la documentation.\nPour accéder à la documentation de <b>Leek Wars</b>, rendez vous dans l’onglet Aide, puis cliquez sur Documentation.",
	"doc_10": "Le type de retour de la fonction et une description de ce retour",
	"doc_11": "Le niveau minimal pour utiliser cette fonction",
	"doc_12": "Si vous avez des doutes sur l’utilisation d’une fonction ou si vous rencontrez une nouvelle fonction dans ce tutoriel\nou ailleurs, je vous invite à lire sa description dans la documentation afin de bien comprendre son fonctionnement.",
	"doc_13": "Maintenant que nous avons fait le tour de l’environnement de programmation, nous allons commencer à voir le LeekScript !",
	"doc_2": "La page se compose de trois parties :",
	"doc_3": "En haut : un champ de recherche pour trouver plus rapidement une constante ou une fonction",
	"doc_4": "À gauche : Une liste de toutes les fonctions et constantes triées par catégorie",
	"doc_5": "À droite : Toutes les fonctions dans l’ordre alphabétique ainsi que leur description",
	"doc_6": "Les catégories sont les suivantes :",
	"doc_7": "La description d’une fonction vous fournis les informations suivantes :",
	"doc_8": "Une description sur le rôle de la fonction",
	"doc_9": "La liste de ses paramètres, leur type ainsi que leur description",
	"doc_arrays": "<b>Tableaux</b> : fonctions classiques de manipulation de tableaux",
	"doc_chips": "<b>Puces</b> : fonctions relatives aux puces (récupération d’informations sur une/des puces)",
	"doc_fight": "<b>Combat</b> : fonctions relatives au combat en cours (récupération d’informations générales sur l’équipe adverse,\nsur votre équipe, placement par rapport aux positions adverses…)",
	"doc_leeks": "<b>Poireaux</b> : fonctions relatives aux poireaux (récupération de statistiques, de position, équipement d’arme…)",
	"doc_map": "<b>Terrain</b> :  fonctions relatives au terrain (informations de distance entre cellules, position de cellules…)",
	"doc_math": "<b>Math</b> : toutes les fonctions mathématiques qu’on peut trouver dans la plupart des langages",
	"doc_strings": "<b>Chaîne</b> : fonctions classiques de manipulation de chaînes de caractères",
	"documentation": "La Documentation",
	"doc_util": "<b>Utilitaires</b> : fonctions utiles pour vous aider lors du développement de votre IA",
	"doc_weapons": "<b>Armes</b> : fonctions relatives aux armes (récupération d’informations sur une/des armes)",
	"editor": "Découverte de l’éditeur",
	"editor_1": "Pour accéder à l’environnement de programmation, rendez vous sur l’onglet <b>Editeur</b>. <br />\nVoici la page que vous allez trouver :",
	"editor_10": "Voici à quoi ressemble le dialogue d’autocomplétion :",
	"editor_11": "Une fois que vous avez développé votre IA, vous avez la possibilité de la tester en cours d’édition\nen situation de combat grâce à l’arène de test.",
	"editor_12": "En cliquant sur le bouton “Tester”, le dialogue suivant s’ouvre :",
	"editor_13": "Vous pouvez alors sélectionner les adversaires que vous souhaitez affronter ainsi que leur niveau de difficulté,\nles statistiques de l’adversaire sont calculées en fonction de celle de votre poireau :",
	"editor_14": "Les 6 poireaux proposés ont chacun un comportement propre :",
	"editor_15": "Vous pouvez cocher un poireau au minimum et aller jusqu’à 6, vous pouvez ainsi affiner votre test.",
	"editor_2": "On trouve un bouton “Nouvelle IA”, il permet de créer une nouvelle IA, et au dessous de ce bouton se trouve la\nliste de vos IA.",
	"editor_3": "Lors de la création de votre compte, une IA appelée “IA_Exemple” a été créée et équipée automatiquement afin que vous\ndisposiez d’un exemple de code.",
	"editor_4": "Cliquez sur cette IA. Un éditeur de texte s’ouvre avec le code :",
	"editor_5": "En cliquant sur le stylo à côté du nom de l’IA (dans la liste des IA à gauche), le champ devient éditable et vous pouvez ainsi la renommer. <br />\nLe bouton “Supprimer” supprime l’IA actuelle. <br />\nLe bouton “Sauvegarder” enregistre le code de votre IA, le compile et vous indique s’il est valide ou s’il\ncontient des erreurs. <br />\nLe bouton “Tester” permet de lancer un combat dans une arène de test pour vérifier que votre code s’exécute\ncorrectement (nous reviendrons sur cette fonctionnalité un peu plus loin).",
	"editor_6": "En dessous de ces boutons se trouve un éditeur de texte, c’est ici que vous pouvez taper votre code,\nune coloration syntaxique est appliquée suivant le code couleur suivant :",
	"editor_7": "Il est intéressant de noter aussi qu’en plaçant son curseur près d’une parenthèse, accolade ou crochet ouvrant,\nson équivalent fermant est mis en évidence, (inversement quand on place le curseur près d’un fermant).",
	"editor_8": "L’éditeur dispose également de raccourcis claviers qui pourront vous faire gagner du temps lors du développement de vos IA :",
	"editor_9": "La complétion automatique ouvre un dialogue pour compléter la fonction, variable ou constante que vous\nétiez en train d’écrire avec une déjà connue par l’éditeur. <br>\nL’éditeur connaît toutes les fonctions du LeekScript ainsi que leurs paramètres, les constantes de jeu ainsi\nque les fonctions et variables que vous aurez définies.",
	"editor_domingo": "Domingo : IA agressive, uniquement en attaque",
	"editor_guj": "Guj : IA incompréhensible, attaque, se soigne, fuit, vient vers vous… personne ne sait</li>\nvraiment ce que ce poireau veut.",
	"editor_image_1": "L'Éditeur de code de Leek Wars",
	"editor_image_2": "Une IA dans L'éditeur",
	"editor_rioupi": "Rioupi : IA lache, fuis principalement",
	"editor_shortcut_1": "<b>Ctrl + S</b> : Enregistrer/Compiler",
	"editor_shortcut_2": "<b>Ctrl + Q</b> : Lancer un test",
	"editor_shortcut_3": "<b>Ctrl + D</b> : Dupliquer la ligne actuelle ou la sélection",
	"editor_tisma": "Tisma : IA défensive, attaque fuis et se soigne",
	"editor_token_bool": "En turquoise : les booléens",
	"editor_token_comments": "En rouge : les commentaires",
	"editor_token_keywords": "En bleu : les mots clés du langage (if, else, for, var, while…)",
	"editor_token_numbers": "En vert : les valeurs numériques",
	"editor_token_strings": "En orange : les chaînes de caractère",
	"equip_a_weapon": "Équiper une arme",
	"fight": "Combat",
	"fight_chips": "Les puces",
	"fight_chips_1": "Avant d'utiliser une puce, il faut veiller à l'équiper sur notre poireau. Pour l'utiliser, il suffit d'utiliser la fonction\n<a href='documentation/useChip'><b>useChip</b></a>. Le premier paramètre est le code de la puce, par exemple \"<b>CHIP_SHOCK</b>\"\npour la puce \"<b>Décharge</b>\". Le second paramètre est le poireau ciblé :",
	"fight_chips_10": "var enemy = getNearestEnemy();\nwhile (getTP() >= 2) {\n\tuseChip(CHIP_SHOCK, enemy);\n}",
	"fight_chips_2": "var enemy = getNearestEnemy();\nuseChip(CHIP_SHOCK, enemy); // On lance la puce Décharge sur l'ennemi\n\nvar ally = getNearestAlly();\nuseChip(CHIP_CURE, ally); // On lance la puce Guérison sur un allié",
	"fight_chips_3": "La gestion des Points de Tour (PT)",
	"fight_chips_4": "Votre poireau possède un nombre limité de points de tour, utilisés pour effectuer des\nactions comme prendre une arme, tirer, utiliser une puce, parler...",
	"fight_chips_5": "Par défaut, le nombre de PT est fixé à 10. Vous pouvez en obtenir davantage avec les points de capital.\nLe nombre de PT est réinitialisé à la fin de votre tour.",
	"fight_chips_6": "Vous devez donc réfléchir à quelles actions effectuer durant votre tour, et organiser votre code en conséquence.\nLa fonction <b>getTP()</b> (get Turn Points) vous donne le nombre de PT restants.",
	"fight_chips_7": "Un exemple : on veut lancer le sort \"Stalactite\" si il nous reste 6 PT ou plus, sinon on lance le sort \"Décharge\" :",
	"fight_chips_8": "var enemy = getNearestEnemy();\nif (getTP() >= 6) {\n\tuseChip(CHIP_STALACTITE, enemy);\n} else {\n\tuseChip(CHIP_SHOCK, enemy);\n}",
	"fight_chips_9": "Un autre exemple : on veut lancer le sort \"Décharge\" (qui coûte 2 PT) jusqu'a épuisement de nos PT :",
	"fight_ground": "Le terrain",
	"fight_ground_1": "Le terrain sur lequel évoluent les joueurs est une grille\nde <b>613</b> cellules, numérotées dans l'ordre comme le montre la capture ci-dessous :",
	"fight_ground_10": "Note : on peut directement utiliser <a href='documentation/isLeek'><b>isLeek()</b></a> pour savoir si une case contient un poireau",
	"fight_ground_11": "Coordonnées (x, y)",
	"fight_ground_12": "On peut également récupérer les coordonnées\n<b>x</b> et <b>y</b> d'une cellule à l'aide de la fonction <a href='documentation/getCellX'><b>getCellX</b></a> et\n<a href='documentation/getCellY'><b>getCellY</b></a> :",
	"fight_ground_13": "var cell = getCell(); // On récupère notre cellule\nvar x = getCellX(cell); // Position en x de la cellule\nvar y = getCellY(cell); // Position en y de la cellule",
	"fight_ground_14": "La cellule centrale du terrain (numéro <b>306</b>) a les coordonnées <b>(0, 0)</b>;",
	"fight_ground_15": "La cellule en haut à gauche (numéro <b>0</b>) a les coordonnées <b>(-17, 0)</b>;",
	"fight_ground_16": "La cellule en haut à droite (numéro <b>17</b>) a les coordonnées <b>(0, -17)</b>;",
	"fight_ground_17": "La cellule en bas à gauche (numéro <b>595</b>) a les coordonnées <b>(0, 17)</b>;",
	"fight_ground_18": "La cellule en bas à droite (numéro <b>612</b>) a les coordonnées <b>(17, 0)</b>.",
	"fight_ground_19": "Enfin, pour finir avec la gestion des cellules, on peut aussi calculer la distance entre deux cellules (et donc aussi\nentre deux poireaux) à l'aide des fonctions <a href='documentation/getDistance'><b>getDistance</b></a> (distance à vol d'oiseau),\n<a href='documentation/getCellDistance'><b>getCellDistance</b></a> (distance en nombre de cellules) et\n<a href='documentation/getPathLength'><b>getPathLength</b></a> (distance en évitant les obstacles).\nUn exemple, on va calculer la distance entre notre poireau et son ennemi le plus proche :",
	"fight_ground_2": "La numérotation des cellules",
	"fight_ground_20": "var maCellule = getCell();\nvar saCellule = getCell(getNearestEnemy());\nvar distance = getCellDistance(maCellule, saCellule);\nif (distance > 10) {\n\t// l'ennemi le plus proche est à plus de 10 cellules\n}",
	"fight_ground_3": "Grâce à cette numérotation, chaque cellule est identifiable à l'aide d'un seul numéro. On peut récupérer le numéro de\nla cellule sur laquelle se trouve notre poireau à l'aide de la fonction <a href='documentation/getCell'><b>getCell</b></a> :",
	"fight_ground_4": "var maCase = getCell(); // On récupère le numéro de notre cellule",
	"fight_ground_5": "Contenu d'une cellule",
	"fight_ground_6": "Grâce à la fonction <a href='documentation/getCellContent'><b>getCellContent</b></a>, on peut déterminer le contenu d'une cellule :\nest-ce qu'un poireau se trouve dessus, ou bien un obstacle, ou est-elle vide ?",
	"fight_ground_7": "var cell = ...; // une cellule quelconque\nvar content = getCellContent(cell);\nif (content == CELL_EMPTY) {\n\t// la cellule est vide\n} else if (content == CELL_OBSTACLE) {\n\t// la cellule est un obstacle\n} else if (content == CELL_LEEK) {\n\t// la cellule contient un poireau\n}",
	"fight_ground_8": "Si la cellule contient un poireau, on peut récupérer l'id de ce poireau grâce à la fonction\n<a href='documentation/getLeekOnCell'><b>getLeekOnCell</b></a> :",
	"fight_ground_9": "var cell = ...; // une cellule\nif (getCellContent(cell) == CELL_LEEK) {\n\tvar leek = getLeekOnCell(cell); // on récupére l'id du poireau\n\tif (isEnemy(leek)) {\n\t\tsay(\"C'est un ennemi !\");\n\t}\n}",
	"fight_intro": "Nous allons maintenant voir comment réellement combattre dans <b>Leek Wars</b>, en expliquant le système de combat,\npuis comment programmer un bon comportement.",
	"fight_move": "Les déplacements et Points de Mouvement (PM)",
	"fight_move_1": "Se déplacer peut s'avérer utile en combat. Votre poireau possède un nombre fixé de points de mouvements (3 au niveau 1). Un PM équivaut à une cellule, plus vous aurez de PM, plus vous pourrez\nvous déplacer loin sur le terrain.\nPour ce faire, de nombreuses fonctions sont à notre disposition. Elles sont principalement\nde deux sortes : avancer et reculer, vers des cibles diverses.",
	"fight_move_10": "Si notre cible n'est pas un poireau précis mais une cellule ou un groupe de cellules, les fonctions à utiliser seront :\n<a href='documentation/moveTowardCell'><b>moveTowardCell</b></a> et\n<a href='documentation/moveAwayFromCell'><b>moveAwayFromCell</b></a>, pour une seule cellule,\net <a href='documentation/moveTowardCells'><b>moveTowardCells</b></a> et\n<a href='documentation/moveAwayFromCells'><b>moveAwayFromCells</b></a>, pour un groupe de cellules.",
	"fight_move_11": "Une ligne comme cible",
	"fight_move_12": "On peut également avancer ou reculer vers une ligne de cellules. Une ligne de cellules est définie par deux cellules appartenant\nà cette ligne. Par exemple, si un ennemi en face de nous possède une arme de type laser, qui tire en ligne,\non peut chercher à fuir cette ligne qui semble dangereuse :",
	"fight_move_13": "var enemy = ...; // l'ennemi en question\nvar saCellule = getCell(enemy);\nvar maCellule = getCell();\nmoveAwayFromLine(saCellule, maCellule);",
	"fight_move_2": "Un ou des poireau(x) comme cible",
	"fight_move_3": "On peut s'approcher ou s'éloigner d'un poireau (allié ou ennemi) grâce aux fonctions\n<a href='documentation/moveToward'><b>moveToward</b></a> et <a href='documentation/moveAwayFrom'><b>moveAwayFrom</b></a> respectivement :",
	"fight_move_4": "var enemy = getNearestEnemy();\nif (getLife() > 100) {\n\tmoveToward(enemy); // on se rapproche\n\t// attaque...\n} else {\n\tmoveAwayFrom(enemy); // on s'éloigne\n\t// soins...\n}",
	"fight_move_5": "Ces fonctions utilisées telles quelles vont utiliser un nombre de points de mouvements variable, de telle sorte à accomplir au\nmieux leur objectif. Ainsi, si vous êtes à une très grande distance d'un ennemi, <b>moveToward</b> utilisera sans doute tous vos PM,\nalors que si vous êtes collé à cet ennemi, elle n'en utilisera aucun.",
	"fight_move_6": "Pour mieux contrôler le nombre de PM qu'une fonction utilise, vous pouvez indiquer le nombre de PM maximum que la fonction peut utiliser, en deuxième paramètre :\n",
	"fight_move_7": "var enemy = getNearestEnemy();\nmoveToward(enemy, 3); // on avance vers l'ennemi, de 3 cellules max.\nuseWeapon(enemy); // on essaye de lui tirer dessus\nmoveAwayFrom(enemy); // on s'éloigne, d'un nombre illimité de cellules",
	"fight_move_8": "Ces fonctions existent aussi quand notre cible n'est pas un mais plusieurs poireaux :\nfonctions <a href='documentation/moveTowardLeeks'><b>moveTowardLeeks</b></a> et\n<a href='documentation/moveAwayFromLeeks'><b>moveAwayFromLeeks</b></a>, pour s'approcher ou s'éloigner d'un groupe de poireaux.\n",
	"fight_move_9": "Une ou des cellule(s) comme cible",
	"fight_speak": "Parler",
	"fight_speak_1": "Votre poireau peut parler pendant le combat, pour encourager ses alliés, ou bien narguer ses ennemis.\nLa fonction pour faire parler votre poireau est <a href='documentation/say'><b>say</b></a>, et coûte <b>1 PT</b> :",
	"fight_speak_2": "say(\"Vous allez tous finir en soupe !\"); // narguer l'équipe adverse",
	"fight_sys": "Le système de combat",
	"fight_sys_1": "Il faut tout d'abord parler du système de combat de <b>Leek Wars</b>. Les combats sont des matchs à mort par équipe,\npour remporter la victoire, chaque poireau de l'équipe adverse doit être éliminé (vie à zéro).",
	"fight_sys_10": "La fonction <b><a href='documentation/getNearestEnemy'>getNearestEnemy()</a></b> elle, renvoie l'id du poireau le plus proche de vous. Récupérer l'id d'un poireau ennemi va\nservir à l'attaquer principalement.",
	"fight_sys_11": "var enemy = getNearestEnemy(); // On récupère l'id de l'enemi le plus proche\nuseWeapon(enemy); // On lui tire dessus",
	"fight_sys_12": "La fonction <b><a href='documentation/getEnemies'>getEnemies()</a></b> renvoie elle les poireaux ennemis (vivants ou morts) dans\nle combat.",
	"fight_sys_13": "var enemies = getEnemies(); // On récupère un tableau des ids des ennemis\nvar n = 0;\nfor (var enemy in enemies) { // On parcourt tous les ennemis\n\tif (getLife(enemy) > 1000) { // getLife(enemy) renvoie la vie du poireau\n\t\tn++;\n\t}\n}\ndebug(n + \" ennemis ont plus de 1000 PV\");",
	"fight_sys_2": "Ordre de jeu",
	"fight_sys_3": "Les poireaux jouent <b>chacun leur tour</b>. L'ordre est déterminé par la fréquence des poireaux, mais on alterne toujours\nentre les deux équipes : le poireau qui\ta la plus grande fréquence a plus de chances de commencer et faire commencer son équipe, et le deuxième poireau\nà jouer est celui qui a la plus grande fréquence dans l'autre équipe, et ainsi de suite.",
	"fight_sys_4": "Le combat est divisé en tours : quand le dernier poireau a joué, on repasse au premier et le compteur de tours s'incrémente.\nPour éviter des combats infinis, le nombre de tours est limité à <b>64</b> (constante <a href='documentation/MAX_TURNS'>MAX_TURNS</a>).\nQuand le compteur atteint cette limite, le combat se solde par une égalite. Lors d'un combat qui dure longtemps,\nil faudra donc bien veiller à surveiller le compteur de tours. La fonction\n<b><a href='documentation/getTurn'>getTurn()</a></b> donne le tour actuel du combat :",
	"fight_sys_5": "var turn = getTurn();\nif (turn > 60) {\n\t// Le combat va bientot se terminer, il faut se dépêcher de finir...\n}",
	"fight_sys_6": "Une numérotation des joueurs",
	"fight_sys_7": "Chaque poireau possède un code unique numérique (appelé aussi <b>id</b>, pour identifiant), qui permet de le désigner.",
	"fight_sys_8": "La fonction <b><a href='documentation/getLeek'>getLeek()</a></b> renvoie l'id de votre poireau. Récupérer votre id est utile par exemple pour utiliser une puce\nde soin sur vous-même.",
	"fight_sys_9": "var moi = getLeek(); // On récupère l'id de notre poireau\nuseChip(CHIP_CURE, moi); // On lance la puce \"Guérison\" sur nous",
	"fight_weapons": "Les armes",
	"fight_weapons_1": "Prendre une arme",
	"fight_weapons_2": "Prendre une arme est en général la première chose à faire dans un combat. Pour ce faire, il faut équiper l'arme sur\nvotre poireau (bouton \"Modifier\" sur la page du poireau), puis utiliser la fonction\n<a href='documentation/setWeapon'><b>setWeapon</b></a>, par exemple :",
	"fight_weapons_3": "// On prend le pistolet\nsetWeapon(WEAPON_PISTOL);",
	"fight_weapons_4": "Attention ! La fonction <b>setWeapon</b> coûte 1 PT.",
	"fight_weapons_5": "Utiliser une arme",
	"fight_weapons_6": "Maintenant que votre poireau possède une arme, il ne reste plus qu'à attaquer avec. Pour cela, il faut utiliser\nla fonction <a href='documentation/setWeapon'><b>useWeapon</b></a> :",
	"fight_weapons_7": "var enemy = getNearestEnemy();\nuseWeapon(enemy); // attaque",
	"fun_1": "Le LeekScript permet la création de fonctions personnelles qui vont vous permettre d'organiser et de simplifier votre\nIA. Si vous avez écrit une opération complexe et souhaitez la réutiliser un certain nombre de fois dans votre code,\nl'utilisation d'une fonction sera la meilleure solution.",
	"fun_10": "Dans le corps de la fonction, on observe le mot-clé <b>return</b> suivit de la formule de l'hypothénuse.\nCe mot-clé va renvoyer la valeur de l'expression situé à sa droite, ici l'hypothénuse avec comme longueurs des côtés <i>x</i>\net <i>y</i>.",
	"fun_11": "On peut utiliser notre fonction <i>hypot</i> dans notre code de la manière suivante :",
	"fun_12": "var a = 4;\nvar b = 3;\nvar c = hypot(a, b); // c prend la valeur sqrt(4 * 4 + 3 * 3) soit 5",
	"fun_13": "On peut entièrement réécrire le code d'exemple en utilisant notre fonction :",
	"fun_14": "// Définition de la fonction hypot\nfunction hypot(x, y) {\n\treturn sqrt(x * x + y * y);\n}\n\nvar a = 3;\nvar b = 4;\nvar c = hypot(a, b);\na = hypot(b, c) + hypot(c, 4);\nb = hypot(a, c);",
	"fun_15": "Nous avons gagné en lisibilité et réduit la taille du code.",
	"fun_16": "On notera que la fonction <i>hypot</i> existe déjà dans les fonctions prédéfinies du LeekScript (voir la fonction\n<a href='documentation/hypot'>hypot</a> dans la documentation).",
	"fun_17": "Return sans valeur",
	"fun_18": "Le mot clé <b>return</b> peut être utilisé sans expression à sa droite, la fonction renverra dans ce cas là une valeur\n<b>null</b>.",
	"fun_19": "Exemple de <b>return</b> sans valeur :",
	"fun_2": "Une fonction basique",
	"fun_20": "function logarithme(n) {\n\tif (n <= 0) {\n\t\treturn;\n\t}\n\t// reste du calcul...\n}",
	"fun_21": "L'exécution de la fonction étant stoppée au premier return rencontré, si n est inférieur ou égal à 0,\ncette fonction renverra <b>null</b> puis n'effectuera pas le reste du calcul :",
	"fun_22": "var a = logarithme(-5); // a va prendre la valeur null",
	"fun_23": "Récursivité",
	"fun_24": "Une fonction peut appeler une autre fonction, par exemple :",
	"fun_25": "function carre(x) {\n\treturn x * x;\n}\nfunction hypot(x, y) {\n\treturn sqrt(carre(x) + carre(y));\n}\nvar a = hypot(3, 4); // a vaut sqrt(3 * 3 + 4 * 4)",
	"fun_26": "Ainsi, une fonction peut s'appeller elle-même :",
	"fun_27": "function factorielle(n) {\n\tif (n <= 1) return 1;\n\treturn n * factorielle(n - 1);\n}",
	"fun_28": "Cette fonction renvoie la factorielle du nombre n (n!) passé en paramètre (n! = n × (n - 1) × ... × 3 × 2 × 1).\nOn constate qu'elle se contente de renvoyer n × (n - 1)!, ce qui est égal à n!",
	"fun_29": "<b>Attention !</b> Si une fonction s'appelle elle-même sans condition de sortie, ou que deux ou plusieurs fonctions\ns'appellent entre elles de manière cyclique, votre code va boucler à l'infini, et dans le cas du LeekScript, va atteindre\nla limite maximale de la pile, qui est fixée à <b>200</b>. Ainsi, avec une telle limite, votre code pourra\ncalculer au maximum la factorielle de <i>200</i>.",
	"fun_3": "Nous allons prendre l'exemple d'un code qui calcule l'hypothénuse d'un triangle rectangle, de côtés de longueur\n<i>a</i>, <i>b</i> et <i>c</i>. Si le côté de longueur <i>c</i> est l'hypoténuse, et si <i>a</i> et <i>b</i> sont connus,\n<i>c</i> peut s'obtenir avec le code suivant :",
	"fun_30": "Exemples de codes menant à une surcharge de la pile :",
	"fun_31": "function mauvaiseFactorielle(n) {\n\treturn n * mauvaiseFactorielle(n);\n}\nvar a = mauvaiseFactorielle(5);\n// le code boucle à l'infini et se stoppe à 200 appels",
	"fun_32": "function a() {\n\tb();\n}\nfunction b() {\n\ta();\n}\na(); // a et b s'appellent entre elles en boucle",
	"fun_33": "Niveau des fonctions",
	"fun_34": "Dans le LeekScript, certaines fonctions ont un niveau minimum. Le poireau sur lequel l'IA sera équipée\ndevra donc avoir les conditions requises. Exemple : la fonction <b><a href='documentation/getPathLength'>getPathLength</a></b>\nexige le niveau <b>37</b> :",
	"fun_35": "Niveau d'une fonction",
	"fun_36": "Aller plus loins dans les fonctions",
	"fun_37": "En LeekScript, chaque fonction peut être utilisée comme une variable :",
	"fun_38": "var variable = getLeek;",
	"fun_39": "Cela fonctionne aussi bien avec les fonctions de base du LeekScript qu'avec celles que vous définissez dans votre code. Pour utiliser une fonction dans une variable il faut l'appeler comme une fonction classique :",
	"fun_4": "var c = sqrt(a * a + b * b);",
	"fun_40": "var variable = getLeek;\n\nvariable(); // Revient à utiliser getLeek",
	"fun_41": "On peut par exemple donner une fonction en paramètre :",
	"fun_42": "function ma_fonction(parametre) {\n\tdebug(parametre());\n}\n\nma_fonction(getLeek);",
	"fun_43": "Le LeekScript propose également un type de fonction un peu particulier appelé \"fonction anonyme\", il s'agit de fonctions sans nom, déclarées directement dans une expression.",
	"fun_44": "Cela permet une écriture plus simple, et évite de déclarer une fonction lorsque ce n'est pas utile. Pour déclarer une fonction anonyme, il faut utiliser le mot clé function et directement ouvrir la parenthèse permetant de définir les paramètres, sans préciser de nom.",
	"fun_45": "var ma_fonction = function() { return \"Test\"; };",
	"fun_46": "Pour utiliser une fonction anonyme, c'est exactement comme utiliser une fonction que l'on aurait mise dans une variable :",
	"fun_47": "var ma_fonction = function() { return \"Test\"; };\n\nma_fonction();",
	"fun_48": "Si par exemple on a une fonction qui prend en paramètre une autre fonction, on peut lui passer directement une fonction anonyme, comme par exemple :",
	"fun_49": "function arrayMap(tableau, fonction) {\n\tvar r = [];\n\tfor (var v in tableau) push(r, fonction(v));\n\treturn r;\n}\n\nvar t = arrayMap([1, 2, 3, 4, 5], function(x) { return x ** 2; });\n\ndebug(t); // [1, 4, 9, 16, 25]",
	"fun_5": "Imaginons maintenant que cette formule est utilisée de nombreuses fois dans votre code :",
	"fun_50": "La fonction arrayMap prend un tableau et une fonction et retourne un nouveau tableau constitué de chaque élément du tableau d'entrée auquel on a appliqué la fonction.",
	"fun_6": "var a = 3;\nvar b = 4;\nvar c = sqrt(a * a + b * b);\na = sqrt(b * b + c * c) + sqrt(c * c + 4 * 4);\nb = sqrt(a * a + c * c);",
	"fun_7": "On remarque qu'il est fastidieux de recopier sans cesse la même formule, tout en compliquant de manière importante notre\ncode. <br />\nOn va donc créer une fonction <i>hypot</i> qui va directement calculer l'hypoténuse. Cette fonction est définie par le code\nsuivant :",
	"fun_8": "function hypot(x, y) {\n\treturn sqrt(x * x + y * y);\n}",
	"fun_9": "Analysons ce code. Pour déclarer une fonction, on utilise le mot-clé <b>function</b>, on note ensuite le nom de\nla fonction, ici <i>hypot</i>. On écrit ensuite entre parenthèses la liste des paramètres, séparés par des virgules, ici \"x\" et \"y\".\nLe corps de la fonction est ensuite entre accolades.",
	"functions": "Les fonctions",
	"interface": "L'interface",
	"intro": "<b>LeekScript</b> est le langage de programmation dedié à la création d'intelligences artificielles pour poireau. Sa syntaxe est très proche du Javascript et ne devrait pas perturber les adeptes de la programmation en C, Java ou même PHP. Si vous débutez totalement en la matière ou souhaitez connaître certaines subtilités du <b>LeekScript</b>, ce tutoriel est fait pour vous :)",
	"loops": "Les boucles",
	"loops_1": "Nous allons maintenant nous intéresser un autre type de structure tout aussi fondamental que les conditions :\nles boucles !",
	"loops_10": "La boucle <b>do while</b> est similaire à la boucle <b>while</b>, excepté que la condition se situe à la fin, le corps de la boucle est donc exécuté toujours au moins une fois :",
	"loops_11": "var x;\ndo {\n\tx = rand(); // x est un nombre aléatoire entre 0 et 1\n} while (x < 0.8); // on répète tant que x n'est pas supérieur à 0.8\n\ndebug(\"x : \" + x); // affiche un nombre entre 0.8 et 1",
	"loops_12": "La boucle for",
	"loops_13": "Un autre type de boucle un petit peu plus complexe existe, il ressemble à une boucle while mais en plus condensé.\nVous verrez à l’usage que selon les cas d’utilisation il est plus pratique d’utiliser un <b>for</b> ou un while.",
	"loops_14": "La boucle <b>for</b> se compose de trois parties :",
	"loops_15": "L’initialisation : l’assignation d’une valeur de départ à une variable “compteur”",
	"loops_16": "La condition : tant qu’elle est valide la boucle continue de s’exécuter",
	"loops_17": "L’incrémentation : faire augmenter (ou diminuer selon le cas) la valeur de votre variable “compteur”",
	"loops_18": "Exemple de boucle <b>for</b> :",
	"loops_19": "var i;\n// On fait une boucle de i = 1 tant que i est inférieur ou égal à 5\n// et on incrémente i à chaque tour de boucle\nfor (i = 1; i <= 5; i++) {\n\tdebug(\"Le compteur i vaut : \" + i);\n}",
	"loops_2": "La boucle permet de répéter des instructions plusieurs fois. Il y a plusieurs types de boucles. Nous allons les voir dans\ncette partie.",
	"loops_20": "Ce code affichera dans les logs :<br />\nLe compteur i vaut 1<br />\nLe compteur i vaut 2<br />\nLe compteur i vaut 3<br />\nLe compteur i vaut 4<br />\nLe compteur i vaut 5",
	"loops_21": "Il est possible de déclarer le compteur dans l’initialisation de la boucle for en mettant le mot clé var\ndevant le nom de variable :",
	"loops_22": "for (var i = 1; i <= 5; i++) {\n\t// Instructions...\n}",
	"loops_23": "Il existe une autre variante de boucle for, la structure : <b>for</b> ... <b>in</b>, qui permet de boucler sur les valeurs d'un\ntableau directement.\nUn exemple :",
	"loops_24": "var tableau = [1,1,2,3,5,8,13,21];\nfor (var valeur in tableau) {\n\tdebug(valeur);\n}",
	"loops_25": "Le code affichera successivement toutes les valeurs du tableau : 1,1,2,3,5,8,13,21.",
	"loops_26": "Si vous souhaitez aussi récupérer la clé associée à chaque valeur du tableau, vous pouvez utiliser le <b>for</b> ...\n<b>in</b> en ajoutant :",
	"loops_27": "for (var cle : var valeur in tableau) {\n\tdebug(\"clé \" + cle + \" => \" + valeur);\n}",
	"loops_3": "La boucle while",
	"loops_4": "La boucle while (tant que) a une syntaxe similaire au if vu dans le chapitre\nprécédent. Elle permet d’exécuter un bloc d’instruction tant qu’une condition\nest remplie.",
	"loops_6": "Voici un exemple :",
	"loops_7": "// On déclare un compteur qu’on initialise à 0\nvar compteur = 0;\nwhile (compteur < 5) { // Tant que le compteur est inférieur à 5\n\tcompteur = compteur + 1;\n\tdebug(\"Compteur vaut \" + compteur);\n}",
	"loops_8": "Ce code affichera dans les logs lors de son exécution : <br />\nCompteur vaut 1<br />\nCompteur vaut 2<br />\nCompteur vaut 3<br />\nCompteur vaut 4<br />\nCompteur vaut 5",
	"loops_9": "La boucle do while",
	"menu": "Menu",
	"presentation": "Présentation",
	"presentation_1": "<b>Leek Wars</b> vous permet d’élever vos poireaux, de leur faire équiper des armes, des puces (sortes de sorts),\net de programmer leur propre intelligence artificielle afin de les faire combattre contre les poireaux des\nautres éleveurs !",
	"presentation_2": "Pour bien commencer, nous allons dans un premier temps voir comment équiper une arme ou une puce sur votre poireau\nafin qu’il puisse participer sans encombre à des combats.",
	"test_config": "La configuration du test",
	"the_documentation": "La documentation",
	"title": "Tutoriel",
	"var_1": "Qu’est ce qu’une variable ?",
	"var_10": "Pour utiliser une variable, il est nécessaire de la déclarer au préalable. Cette déclaration se fait en utilisant\nle mot clé “var” de la manière suivante :",
	"var_11": "// On déclare la variable nomDeVariable\nvar nomDeVariable;",
	"var_12": "Il est également possible d’attribuer une valeur à votre variable de la manière suivante :",
	"var_13": "// On déclare la variable nomDeVariable et on lui assigne la valeur 12\nvar nomDeVariable = 12;",
	"var_14": "À noter qu’on peut également déclarer plusieurs variables en les séparant par une virgule :",
	"var_15": "// Déclaration de premiereVariable et deuxiemeVariable\nvar premiereVariable, deuxiemeVariable;",
	"var_16": "Attention à ne pas oublier le point-virgule <b>;</b> à la fin de l’instruction.",
	"var_17": "Les variables déclarées avec le mot clé var ont comme durée de vie le tour de votre poireau,\nil existe un second type de variable qui gardent leur valeur durant toute la durée du combat : les variables globales.\nPour déclarer une variable globale, il suffit d’utiliser le mot-clé “global” au lieu de “var” :",
	"var_18": "// Déclaration d’une variable globale\nglobal nomDeGlobale;",
	"var_19": "Il est également possible d’assigner une valeur à une globale lors de sa déclaration :",
	"var_2": "Les variables sont un point fondamental dans tous les langages de programmation. Elles permettent de garder\n\t\t\ten mémoire des valeurs afin de les réutiliser dans des calculs.",
	"var_20": "// Déclaration de la variable globale nomDeGlobale, de valeur 42\nglobal nomDeGlobale = 42;",
	"var_21": "Les variables et variables globales peuvent s’utiliser de la même manière dans le code, dans la suite\ndu tuto nous utiliserons principalement des variables normales (parfois appelées locales).",
	"var_22": "Utilisation des variables",
	"var_23": "Il est possible d’utiliser les variables dans votre code de différentes façons.",
	"var_24": "On peut leur assigner une valeur (c’est à dire leur faire “retenir” cette valeur en mémoire) en utilisant\nl’opérateur d’assignation <b>=</b> :",
	"var_25": "// On déclare maVariable\nvar maVariable;\n// On assigne 1 à maVariable\nmaVariable = 1;",
	"var_26": "Il est possible d’effectuer des calculs écrivant des expressions, vous pouvez utiliser les opérateurs suivants :",
	"var_27": "+ : addition",
	"var_28": "- : soustraction",
	"var_29": "* : multiplication",
	"var_3": "Les variables proposées par le LeekScript peuvent contenir plusieurs types de valeur",
	"var_30": "/ : division",
	"var_31": "% : modulo (reste d’une division euclidienne)",
	"var_32": "On procède ainsi :",
	"var_33": "// Déclaration de la variable a\nvar a;\n// On effectue quelques calculs\na = 2 + 8; // a prend la valeur 10\na = 5 - 4; // a prend la valeur 1\na = 3 * 5; // a prend la valeur 15\na = 6 / 2; // a prend la valeur 3\na = 8 % 3; // a prend la valeur 2\n\n// Mais on peut également combiner les opérateurs\na = 1 + 2 * 3; // a prend la valeur 7\na = 4 / 2 + 1; // a prend la valeur 3\n\n// Et même utiliser des parenthèses\na = (2 + 3) * 2; // a prend la valeur 10",
	"var_34": "On peut également utiliser une variable dans une expression, sa valeur sera utilisée pour\neffectuer le calcul. Par exemple :",
	"var_35": "// Déclaration de la variable a et b\nvar a, b;\n\n// On assigne la valeur 10 à a\na = 10; // a prend la valeur 10\n\n// On assigne la valeur a + 5 à b\nb = a + 5; // b prend la valeur 15",
	"var_36": "On peut également utiliser des chaînes de caractères de la manière suivante :",
	"var_37": "var maVariable;\nmaVariable = \"Je suis une chaîne de caractères\";",
	"var_38": "Pour une chaîne de caractère, seul l’opérateur <b>+</b> est utilisable, il permet de concaténer des morceaux\nde chaîne, c’est à dire de les mettre bout à bout. Comme le montre le code :",
	"var_39": "// Déclaration de chaine1 et chaine2\nvar chaine1, chaine2;\n\nchaine1 = \"Bonjour \"; // chaine1 prend la valeur \"Bonjour \"\nchaine2 = chaine1 + \" tout le monde\"; // chaine2 vaut \"Bonjour tout le monde\"",
	"var_4": "Chaîne de caractères",
	"var_40": "Il est intéressant de noter qu’on peut concaténer une chaîne avec un nombre, cela peut être utile\npour inclure le résultat d’un calcul dans une chaîne :",
	"var_41": "// Déclaration de a et chaine\nvar a, chaine;\n\na = 51 * 17; // a prend la valeur 867\nchaine = \"Multiplier 51 et 17 donne la valeur : \" + a;\n// chaine contient alors \"Multiplier 51 et 17 donne la valeur : 867\"",
	"var_42": "Un bon réflexe en LeekScript",
	"var_43": "Ce que nous allons voir maintenant est un outil qui va vous être très utile dans le développement de votre IA,\nil s’agit d’une fonction vous permettant d’afficher la valeur de variable ou d’expressions.",
	"var_44": "Nous n’avons pas encore vu comment utiliser de fonction et nous expliqueront leur mécanisme plus en détail un peu plus\nloin dans ce cours, pour le moment nous allons juste apprendre à utiliser \"debug\".",
	"var_45": "<i>debug</i> est une fonction du LeekScript qui permet d’afficher dans les log de combat (il s’agit un peu d’une\nsortie standard).\nVous pourrez donc en savoir un peu plus sur l’exécution de votre script.\nNous allons apprendre à l’utiliser.",
	"var_46": "Rendez vous dans l’éditeur et créez une nouvelle IA, mettez y le code suivant :",
	"var_47": "debug(\"Je suis un texte de test\");",
	"var_48": "Lancez un combat de test et faites “Quitter” (la petite croix en bas)  afin d’accéder directement au\nrapport de combat. Cliquez sur le sous onglet “Actions”, vous arrivez alors sur cette page :",
	"var_49": "La fonction debug() en action",
	"var_5": "Nombre",
	"var_50": "Cette page récapitule toutes les actions du combat, vous pouvez remarquer qu’à chaque début de votre tour,\nune ligne : “[VotrePoireau] Je suis un texte de test” apparaît.",
	"var_51": "A chaque fois que la fonction <i>debug</i> est appelée, la valeur fournie en paramètre est ajoutée dans les logs dans la\nchronologie du combat, vous pouvez donc voir à quel moment du combat s’execute l’instruction.\nVous pouvez afficher la valeur d’une variable, le résultat d’un calcul...",
	"var_52": "// Affichage d’un texte simple\ndebug(\"Texte simple\"); // Affiche : [VotrePoireau] Texte simple\ndebug(5 + 6); // Affiche : [VotrePoireau] 11\n\nvar a = 5;\ndebug(a); // Affiche : [VotrePoireau] 5\ndebug(\"Valeur de a : \" + a); // Affiche : [VotrePoireau] Valeur de a : 5",
	"var_53": "Cette fonction peut vous faire gagner un temps précieux lorsque vous avez un bug dans votre code donc\nn’hésitez pas à l’utiliser.<br>\nA noter que vous ne pouvez voir que les messages de debug de vos poireaux (et inversement, vos adversaires ne pourront\npas voir vos messages de debug)",
	"var_6": "Booléen (vrai ou faux)",
	"var_7": "Tableau (nous y reviendrons un peu plus loin)",
	"var_8": "null",
	"var_9": "Cependant le type de la variable n’est pas fixe (comme en C ou en Java) mais s'adapte aux données que\nl’on souhaite y stocker (comme en JavaScript ou en PHP).",
	"variables": "Les variables",
	"welcome": "Bienvenue dans le tutoriel LeekScript !",
	"what_is_ai": "Qu’est-ce qu’une IA ?",
	"what_is_ai_1": "Une <b>Intelligence Artificielle</b> (<b>IA</b>) est un code en <i>LeekScript</i> qui va contrôler votre poireau durant son tour de jeu.\nLe code que vous allez créer sera exécuté à chaque début de tour de votre poireau, il contrôlera les actions que votre\npoireau va effectuer (attaquer, se déplacer, utiliser une puce…).",
	"what_is_ai_2": "Lorsqu’un combat est lancé, vous ne pouvez plus intervenir sur les actions de votre protégé: seule l’IA est prise en compte,\nc’est pourquoi il est primordial de la programmer avec soin.",
	"what_is_ai_3": "Nous allons maintenant voir l’environnement proposé par <b>Leek Wars</b> pour développer votre IA.",
	"what_is_leekscript": "Qu’est ce que le LeekScript ?",
	"what_is_leekscript_1": "Maintenant que vous avez une arme, nous allons pouvoir nous pencher sur la partie création d'intelligences\nArtificielle (IA) qui est le sujet de ce tutoriel. <b>Leek Wars</b> vous propose de programmer vos IA dans un langage\nappelé le LeekScript, il s’agit d’un langage proche du Javascript et du PHP, non typé et non orienté objet.",
	"what_is_leekscript_2": "Le langage est facile à utiliser et à apprendre. Il met à votre disposition des fonctions puissantes qui vous\npermettront de créer une IA efficace même si vous débutez. A l’inverse, si vous êtes déjà expérimentés en\nprogrammation, des fonctions plus poussées vous permettrons de créer des IA plus sophistiquées."
}